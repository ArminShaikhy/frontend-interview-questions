### 1. چگونه جریان احراز هویت را در یک برنامه React با استفاده از OAuth 2.0 و ارائه‌دهنده شخص ثالث (مثل Google، Auth0) طراحی می‌کنید؟

از یک ارائه‌دهنده OAuth (مثل Auth0 یا Google) با **جریان کد احراز هویت + PKCE** برای برنامه‌های تک‌صفحه‌ای (SPA) استفاده کنید.

**مراحل**:

1. هدایت کاربر به URL ورود ارائه‌دهنده.
2. دریافت `code` در URI هدایت.
3. تبادل `code` برای توکن‌های دسترسی + تازه‌سازی از طریق بک‌اند امن یا SDK.
4. ذخیره امن توکن‌ها در حافظه یا کوکی‌های `httpOnly`.

<br />

### 2. رویکرد شما برای پیاده‌سازی احراز هویت مبتنی بر JWT در یک برنامه React، شامل ذخیره توکن و مکانیزم‌های تازه‌سازی چیست؟

- **توکن دسترسی**: کوتاه‌مدت، ذخیره در حافظه یا `sessionStorage`.
- **توکن تازه‌سازی**: هرگز در `localStorage`. از کوکی `httpOnly` برای مدیریت امن استفاده کنید.

**جریان**:

1. در ورود، دریافت توکن‌های دسترسی + تازه‌سازی.
2. ذخیره توکن دسترسی در حافظه.
3. در صورت دریافت 401، فراخوانی نقطه پایانی تازه‌سازی (اگر توکن تازه‌سازی موجود باشد).
4. تازه‌سازی خودکار از طریق تایمر پس‌زمینه یا رهگیر.

<br />

### 3. چگونه احراز هویت چندمرحله‌ای (MFA) را در یک فرانت‌اند React مدیریت می‌کنید و چه ملاحظات تجربه کاربری را در اولویت قرار می‌دهید؟

**جریان**:

1. پس از احراز هویت موفق نام کاربری/رمز عبور، بررسی پرچم MFA.
2. نمایش ورودی MFA (TOTP، SMS).
3. در صورت موفقیت، صدور توکن دسترسی کامل.

**اولویت‌های تجربه کاربری**:

- انتقال بی‌درز از ورود → MFA.
- پشتیبانی از روش‌های جایگزین.
- پیام‌رسانی خطای واضح + امکان امتحان مجدد.

<br />

### 4. استراتژی شما برای مدیریت جلسات کاربر در یک برنامه تک‌صفحه‌ای (SPA) با React چیست؟

- استفاده از **انقضای توکن** و **تایمرهای عدم فعالیت**.
- ذخیره حداقل متادیتای کاربر در حالت جهانی (مثل Redux، Zustand).
- تازه‌سازی خودکار یا درخواست احراز هویت مجدد در صورت انقضای توکن.
- حفظ حالت احراز هویت در هنگام رفرش از طریق کوکی‌های امن یا `sessionStorage` رمزنگاری‌شده.

<br />

### 5. چگونه یک سیستم کنترل دسترسی مبتنی بر نقش (RBAC) را در یک برنامه React با استفاده از داده‌های احراز هویت پیاده‌سازی می‌کنید؟

استفاده از نقش‌ها/مجوزها از JWT یا متادیتای کاربر.

```jsx
const hasPermission = (user, permission) =>
  user?.permissions?.includes(permission);

رندر شرطی کامپوننت‌ها یا مسیرها:
{
  hasPermission(user, "admin:view") && <AdminPanel />;
}

می‌توان در سطح مسیر با استفاده از HOCها یا نگهبان‌های مسیر سفارشی اعمال کرد.


6. چگونه مکانیزم خروج را در یک برنامه React طراحی می‌کنید که اطمینان دهد تمام حالت‌ها و توکن‌های سمت کلاینت به‌صورت امن پاک می‌شوند؟

پاک‌سازی توکن‌ها (حافظه، ذخیره‌سازی).
ابطال توکن تازه‌سازی در بک‌اند.
هدایت به صفحه ورود.

اگر از کوکی‌ها استفاده می‌شود، یک نقطه پایانی بک‌اند برای پاک‌سازی کوکی سرور فراخوانی کنید.


7. رویکرد شما برای مدیریت احراز هویت در یک برنامه React رندرشده سمت سرور (SSR) چیست؟

استفاده از getServerSideProps برای بررسی وضعیت احراز هویت از طریق کوکی‌ها.
ذخیره توکن‌ها در کوکی‌های httpOnly برای سازگاری با SSR.
هدایت کاربران غیرمجاز قبل از رندر صفحه.



8. چگونه یک سیستم احراز هویت را با Redux یا Zustand برای مدیریت حالت جهانی ادغام می‌کنید؟

ذخیره اطلاعات کاربر (نه توکن‌ها) در حالت جهانی.
استفاده از میدلور یا افکت‌ها برای رهگیری اقدامات احراز هویت (مثل توکن تازه‌سازی).



9. فرآیند شما برای مدیریت خطاهای احراز هویت (مثل توکن‌های منقضی‌شده، اعتبار نامعتبر) در یک برنامه React چیست؟

استفاده از یک رهگیر مرکزی Axios/Fetch برای گرفتن 401ها.
امتحان مجدد با توکن تازه‌سازی یا هدایت به صفحه ورود.



10. چگونه یک سیستم احراز هویت فرانت‌اند را برای پشتیبانی از سناریوهای چنددامنه‌ای یا چندمنبعی (مثل میکروفرانت‌اندها) طراحی می‌کنید؟

استفاده از کوکی‌های httpOnly مشترک (با CORS + credentials: true).
سرویس احراز هویت متمرکز (مثل ارائه‌دهنده هویت).
استفاده محتاطانه از postMessage یا ذخیره‌سازی iframe مشترک.



11. چالش‌برانگیزترین آسیب‌پذیری امنیتی که در یک برنامه فرانت‌اند با آن مواجه شده‌اید چیست و چگونه آن را برطرف کردید؟

با یک آسیب‌پذیری XSS مواجه شدم که ورودی کاربر بدون پاک‌سازی در innerHTML تزریق می‌شد.

رفع: استفاده از DOMPurify برای پاک‌سازی سمت کلاینت و بازسازی برای عدم استفاده از dangerouslySetInnerHTML.


12. چگونه یک برنامه React را از حملات جعل درخواست بین‌سایتی (CSRF) محافظت می‌کنید؟

استفاده از SameSite=Lax یا Strict برای کوکی‌ها.
پیاده‌سازی توکن‌های CSRF برای درخواست‌های تغییر حالت.
ترجیح کوکی‌های httpOnly به جای localStorage برای کاهش سرقت توکن.



13. رویکرد شما برای ایمن‌سازی فراخوانی‌های API از یک فرانت‌اند React برای جلوگیری از حملات مرد میانی (MITM) چیست؟

استفاده انحصاری از HTTPS.
اعتبارسنجی گواهینامه‌های SSL.
ذخیره توکن‌ها در کوکی‌های httpOnly، بدون افشا در JS.
فعال‌سازی سربرگ‌های HSTS.



14. چگونه یک برنامه React را طراحی می‌کنید تا از افشای داده‌های حساس در مرورگر (مثل در DOM یا کنسول) جلوگیری کند؟

هرگز توکن‌ها یا اطلاعات شناسایی شخصی (PII) را لاگ نکنید.
اجتناب از جاسازی اسرار در DOM یا باندل برنامه.
پوشاندن داده‌ها در پیام‌های خطا و استفاده از مرزهای خطا.



15. استراتژی شما برای ایمن‌سازی اسکریپت‌ها یا کتابخانه‌های شخص ثالث در یک برنامه React چیست؟

استفاده از یکپارچگی زیرمنبع (SRI) در صورت امکان.
ممیزی وابستگی‌ها از طریق ابزارهایی مثل npm audit، Snyk.
لیست سفید دامنه‌های امن از طریق سیاست امنیت محتوا (CSP).



16. چگونه اعتبارسنجی و پاک‌سازی ورودی را در یک فرانت‌اند React برای جلوگیری از حملات تزریق (مثل XSS) پیاده‌سازی می‌کنید؟

استفاده از کامپوننت‌های کنترل‌شده.
پاک‌سازی خروجی HTML (مثل DOMPurify).
فرار از تمام محتوای غیرقابل اعتماد.
اعتبارسنجی ورودی‌ها در هر دو فرانت‌اند و بک‌اند.



17. رویکرد شما برای طراحی یک سیاست امنیت محتوا (CSP) برای یک برنامه React چیست؟
Content-Security-Policy:default-src 'self';script-src 'self' [<https://trusted.cdn.com>](<https://trusted.cdn.com/>);object-src 'none';استفاده از نانس‌ها برای اسکریپت‌های درون‌خطی و حالت گزارش‌دهی در طول تست.


18. چگونه امنیت را در یک برنامه React که در یک محیط بدون اعتماد (zero-trust) مستقر شده مدیریت می‌کنید؟

احراز هویت هر درخواست (JWT بدون حالت).
رمزنگاری تمام ارتباطات (TLS).
اصل حداقل امتیاز برای منابع قابل دسترسی فرانت‌اند.
استفاده از توکن‌های دسترسی کوتاه‌مدت و CORS سخت‌گیرانه.



19. فرآیند شما برای انجام ممیزی امنیتی یک فرانت‌اند React قبل از انتشار عمده چیست؟

تحلیل استاتیک با ESLint، Snyk یا SonarQube.
اجرای npm audit و بررسی وابستگی‌ها.
تست نفوذ جریان‌های احراز هویت و نواحی حساس.
بررسی لاگ‌های کنسول و ابزارهای توسعه افشاشده.



20. چگونه یک سیستم فرانت‌اند را برای رعایت استانداردهای امنیتی مثل GDPR یا HIPAA طراحی می‌کنید؟

حداقل‌سازی داده: فقط جمع‌آوری آنچه لازم است.
رضایت صریح برای کوکی‌ها + تحلیل‌ها.
ارائه مکانیزم‌های دانلود/حذف داده کاربر.
ذخیره رضایت به‌صورت امن و قابل تأیید.
HIPAA: اجتناب از ذخیره PHI در فرانت‌اند؛ رمزنگاری تمام داده‌های حساس در حالت استراحت و انتقال.



