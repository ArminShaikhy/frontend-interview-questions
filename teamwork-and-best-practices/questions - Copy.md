### 1. چه بهترین روش‌هایی را هنگام نوشتن کد React در یک محیط تیمی دنبال می‌کنید؟

- **سازمان‌دهی کامپوننت‌ها:** من از ساختار پوشه‌ای مبتنی بر ویژگی (مثل `src/features/کارها/`) پیروی می‌کنم تا کامپوننت‌های مرتبط، استایل‌ها و تست‌ها را کنار هم گروه‌بندی کنم، که ماژولاریتی و قابلیت نگهداری را بهبود می‌بخشد.
- **نام‌گذاری کامپوننت‌ها:** از نام‌های واضح و توصیفی برای کامپوننت‌ها و هوک‌ها (`کارت_کاربر`، `useFetchUser`) استفاده می‌کنم و برای کامپوننت‌ها از PascalCase و برای متغیرها/توابع از camelCase پیروی می‌کنم.
- **مدیریت حالت:** حالت را تا حد ممکن محلی نگه می‌دارم. برای حالت جهانی، بر اساس پیچیدگی از ابزارهایی مثل **Redux Toolkit**، **Zustand** یا **React Context** استفاده می‌کنم.
- **اجتناب از حفاری پراپ‌ها:** برای کامپوننت‌های عمیقاً تودرتو، منطق را به زمینه یا هوک‌های سفارشی استخراج می‌کنم.
- **هوک‌ها و استفاده مجدد منطق:** منطق کسب‌وکار به هوک‌های سفارشی (`useForm`، `useDebounce`) منتقل می‌شود تا قابلیت استفاده مجدد و تست‌پذیری داشته باشد.
- **فرهنگ بررسی کد:** من از بررسی‌های منظم PR با لینتینگ/تست‌های اجباری CI حمایت می‌کنم تا کیفیت کد و هم‌راستایی تیم تضمین شود.

<br />

### 2. چگونه اطمینان می‌دهید که کد React شما تمیز، خوانا و مطابق با استانداردهای یکنواخت است؟

**رویکرد:**

- **لینتینگ و قالب‌بندی:** از **ESLint** (با پیکربندی Airbnb یا سفارشی) و **Prettier** یکپارچه‌شده در جریان توسعه (CI + IDE) استفاده می‌کنم تا نحو و قالب‌بندی یکنواخت را اعمال کنم.
- **TypeScript:** به‌شدت TypeScript را ترجیح می‌دهم تا با تایپ‌سازی استاتیک، وضوح را بهبود داده و از اشکالات زمان اجرا جلوگیری کنم.

**کامپوننت‌های تابعی و هوک‌ها:** کامپوننت‌ها را به‌صورت توابع خالص می‌نویسم و از کامپوننت‌های کلاسی اجتناب می‌کنم مگر اینکه کد قدیمی آن را الزامی کند.

- **اصل مسئولیت واحد:** هر کامپوننت یک نگرانی واحد را مدیریت می‌کند. اگر کامپوننت بیش از حد بزرگ شود، رابط کاربری/منطق را به زیرکامپوننت‌ها یا هوک‌های سفارشی بازسازی می‌کنم.
- **نام‌گذاری و معناشناسی:** نام‌گذاری توصیفی، HTML معنایی (`<section>`، `<article>`) و ویژگی‌های ARIA برای دسترسی‌پذیری.

**مثال:**

```tsx
const UserList = ({ users }: { users: User[] }) => (
  <ul>
    {users.map((user) => (
      <li key={user.id}>{user.name}</li>
    ))}
  </ul>
);

تمیز، تایپ‌شده و ساده.


3. چگونه کنترل نسخه و همکاری در یک پروژه React با چندین توسعه‌دهنده را مدیریت می‌کنید؟
روش‌ها:

جریان کاری Git: من از Git Flow یا GitHub Flow پیروی می‌کنم، با شاخه‌های ویژگی کوتاه‌مدت (feature/صفحه_ورود)، درخواست‌های کشش و بررسی‌های کد.
محافظت از شاخه و CI: بررسی‌های PR، تست‌های خودکار و لینتینگ را قبل از ادغام از طریق ابزارهایی مثل GitHub Actions یا CircleCI اجباری می‌کنم.
مالکیت کد: کامپوننت‌ها و ویژگی‌ها توسط توسعه‌دهندگان یا گروه‌های خاص مالکیت می‌شوند. مالکیت ابهام را کاهش داده و بررسی‌ها را تسریع می‌کند.
مستندسازی: APIهای کامپوننت و الگوهای استفاده را از طریق Storybook یا مستندات داخلی مستند می‌کنم تا همکاری و ورود آسان‌تر شود.
تعارض‌های ادغام: به‌طور منظم از main یا develop کشیده و بازسازی می‌کنم تا از تعارض‌های بزرگ و شگفتی‌های یکپارچگی جلوگیری کنم.



4. چگونه با آخرین تغییرات در React و توسعه فرانت‌اند به‌روز می‌مانید؟
استراتژی‌ها:

کانال‌های رسمی: وبلاگ React، بحث‌های GitHub و RFCها را برای ویژگی‌های آتی و جهت‌گیری (مثل React Server Components) دنبال می‌کنم.
خبرنامه‌های گزینش‌شده: در React Status، Frontend Focus و JavaScript Weekly اشتراک می‌کنم.
جوامع: در توییتر توسعه‌دهندگان، Stack Overflow و Reddit مشارکت می‌کنم تا از ابزارهای اکوسیستم (مثل Vite، TanStack، SWR) مطلع باشم.
آزمایش: به‌طور منظم با کتابخانه‌ها یا الگوهای جدید در پروژه‌های جانبی یا آزمایش‌های Codesandbox نمونه‌سازی می‌کنم.
کنفرانس‌ها و گفتگوها: سخنرانی‌های ReactConf، JSConf و دیدارهای محلی را تماشا می‌کنم. همچنین گاهی یافته‌ها را به تیم ارائه می‌دهم.



5. چگونه اطمینان می‌دهید که کامپوننت‌های React شما قابل استفاده مجدد و قابل نگهداری هستند؟
تکنیک‌های کلیدی:

جداسازی نگرانی‌ها: کامپوننت‌های نمایشی (احمق) و کانتینر (هوشمند) را جدا می‌کنم. کامپوننت‌های نمایشی تمام داده‌ها را از طریق پراپ‌ها دریافت می‌کنند.
هوک‌های سفارشی: منطق مشترک را به هوک‌ها استخراج می‌کنم. مثال: useFormValidation، usePagination و غیره.
پراپ‌های ترکیبی: از پراپ‌هایی مثل renderItem، children یا as برای گسترش‌پذیری کامپوننت‌ها استفاده می‌کنم.

مثال:
const List = ({
  items,
  renderItem,
}: {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}) => <ul>{items.map(renderItem)}</ul>;


تایپ‌های پراپ و پیش‌فرض‌ها: از رابط‌های TypeScript و پیش‌فرض‌های منطقی برای خود-مستندسازی کامپوننت‌ها استفاده می‌کنم.
اجتناب از انتزاع بیش از حد: کامپوننت‌ها را فقط زمانی تعمیم می‌دهم که مورد استفاده مجدد واضحی وجود داشته باشد، و از تعمیم زودهنگام اجتناب می‌کنم.
تست: هر کامپوننت قابل استفاده مجدد با تست‌های واحد با استفاده از React Testing Library پوشش داده می‌شود تا عملکرد مورد انتظار در موارد استفاده مختلف تضمین شود.



