### 1. چگونه یک معماری فرانت‌اند طراحی می‌کنید که بتواند برای میلیون‌ها کاربر مقیاس‌پذیر باشد و در عین حال عملکرد و بهره‌وری توسعه‌دهندگان را حفظ کند؟

**رویکرد:**

- **عملکرد**: استفاده از **تقسیم کد** (`React.lazy`)، **کش CDN**، **حذف کد غیرضروری** و **بهینه‌سازی مسیر رندرینگ بحرانی**.
- **مقیاس‌پذیری**: اتخاذ **معماری مدولار**، ساختار پوشه‌ای مبتنی بر ویژگی و **میکروفرانت‌اندها** برای تیم‌های بزرگ.
- **بهره‌وری توسعه‌دهندگان**: اعمال استانداردها از طریق **لینتینگ**، **Prettier**، **TypeScript** و **Storybook** برای کامپوننت‌های قابل استفاده مجدد.
- **ابزارها**: استفاده از **Vite** یا **ESBuild** برای ساخت سریع و **خطوط لوله CI/CD** برای اطمینان در مقیاس‌پذیری.

<br />

### 2. پیامدهای بلندمدت انتخاب معماری مبتنی بر کامپوننت (مثل React) در مقایسه با پارادایم‌های دیگر مانند MVC یا طراحی‌های فرانت‌اند یکپارچه چیست؟

- **مزایا**:
  - کپسوله‌سازی: منطق/رابط کاربری/حالت به‌صورت محلی هستند.
  - قابلیت استفاده مجدد: از طریق کتابخانه‌های کامپوننت، اصل DRY را ترویج می‌دهد.
  - مقیاس‌پذیری: امکان استفاده از میکروفرانت‌اندها یا مرزهای تیمی مدولار را فراهم می‌کند.
- **معایب**:
  - می‌تواند به **دریلینگ پراپ‌ها** یا **کامپوننت‌های عمیقاً تودرتو** منجر شود اگر با زمینه/هوک‌ها/کتابخانه‌های حالت مدیریت نشود.
  - خطر **انتزاع بیش‌ازحد** در صورت تعمیم زودهنگام کامپوننت‌ها.

<br />

### 3. چگونه بین نیاز به توسعه سریع ویژگی‌ها و ایجاد یک سیستم فرانت‌اند مقاوم و آینده‌نگر تعادل برقرار می‌کنید؟

- استفاده از **پرچم‌های ویژگی** برای تحویل تدریجی.
- تعریف و اعمال **قراردادهای کد** و **توکن‌های طراحی**.
- سرمایه‌گذاری زودهنگام در **کتابخانه‌های کامپوننت قابل استفاده مجدد**.
- ایجاد **محدودیت‌ها** (مثل CI، لینتینگ، تایپ‌ها) که سرعت را بدون ایجاد اصطکاک حفظ می‌کنند.

<br />

### 4. در یک معماری میکروفرانت‌اند، چگونه یکنواختی بین تیم‌ها را تضمین می‌کنید و در عین حال خودمختاری در انتخاب فناوری را فراهم می‌کنید؟

- **سیستم طراحی**: توکن‌های طراحی متمرکز و کامپوننت‌های رابط کاربری (مثل Storybook یا Bit).
- **قراردادها**: استفاده از **تایپ‌های مشترک TypeScript** یا اسکیماهای GraphQL.
- **ارتباط فناوری‌ناآگاه**: استفاده از رویدادهای بومی مرورگر یا گذرگاه‌های پیام (مثل `postMessage`) برای ارتباط بین‌برنامه‌ای.

<br />

### 5. چگونه یک برنامه React به‌هم‌پیوسته را به یک سیستم مدولار و کم‌پیوسته بازسازی می‌کنید بدون اختلال در توسعه جاری؟

- **الگوی خفه‌کننده**: جایگزینی تدریجی ماژول‌ها.
- استخراج منطق قابل استفاده مجدد به **هوک‌های سفارشی**.
- معرفی **مرزهای ویژگی** (مثل `features/Profile`) با استایل‌ها، کامپوننت‌ها و تست‌های محدود.
- استفاده از **لایه‌های رابط** یا آداپتورها برای جداسازی وابستگی‌ها.

<br />

### 6. چالش‌برانگیزترین مشکل عملکردی که در یک برنامه فرانت‌اند با آن مواجه شده‌اید چیست و چگونه آن را حل کردید؟

**مشکل**: یک گرید داده React بیش از ۱۰,۰۰۰ ردیف را در هر تعامل رندر مجدد می‌کرد.

**راه‌حل**:

- رندرینگ مجازی‌سازی‌شده با `react-window`.
- مموایزیشن با `React.memo` و `useMemo`.
- به‌روزرسانی‌های حالت دسته‌ای با استفاده از `startTransition` (React 18+).

<br />

### 7. چگونه تصمیم می‌گیرید که یک بهینه‌سازی عملکردی (مثل مموایزیشن، بارگذاری تنبل) زودهنگام است یا ضروری؟

**زودهنگام**: وقتی بهینه‌سازی پیچیدگی را بدون تأثیر قابل اندازه‌گیری بر کاربر اضافه می‌کند.

**ضروری**:

- تأخیر قابل اندازه‌گیری (مثل TTI یا FID کند).
- گلوگاه‌ها در جریان‌های اصلی کاربر.
- **بررسی** ابتدا با ابزارهایی مثل Lighthouse، Web Vitals و React Profiler.

<br />

### 8. درباره مزایا و معایب رندرینگ سمت کلاینت، رندرینگ سمت سرور و تولید سایت استاتیک در برنامه‌های React چگونه فکر می‌کنید؟

| استراتژی      | مزایا                        | معایب                         |
| ------------- | --------------------------- | ---------------------------- |
| CSR           | تعامل سریع                 | سئو ضعیف، رنگ‌آمیزی اولیه کند |
| SSR (Next.js) | سئو خوب، پویا              | هزینه سرور بالاتر            |
| SSG           | تحویل سریع‌ترین، سئو عالی  | برای داده‌های پویا ایده‌آل نیست |

**قانون کلی**:

- **SSR** برای محتوای پویا که نیاز به سئو دارد.
- **SSG** برای صفحات بازاریابی.
- **CSR** برای برنامه‌های پشت احراز هویت.

<br />

### 9. نقش خط لوله رندرینگ مرورگر در عملکرد فرانت‌اند چیست و چگونه از آن برای کاهش تکان یا تکان‌های چیدمان استفاده می‌کنید؟

**مراحل**: JS → استایل → چیدمان → رنگ‌آمیزی → ترکیب

**برای بهینه‌سازی**:

- جلوگیری از تکان‌های چیدمان: دسته‌بندی خواندن/نوشتن DOM.
- استفاده از `will-change`، `transform`، `opacity` برای انیمیشن‌های کارآمد.
- اجتناب از reflowهای اجباری (مثل خواندن `offsetHeight` پس از تغییر استایل).

<br />

### 10. چگونه یک برنامه React را برای دستگاه‌های کم‌توان یا شرایط شبکه ضعیف بهینه می‌کنید؟

- **حجم باندل**: تقسیم بر اساس مسیر با `React.lazy`.
- **تأخیر اسکریپت‌های غیربحرانی** و دارایی‌ها.
- **کاهش رندرهای مجدد** با `memo`، `useMemo`، `useCallback`.
- **لودرهای اسکلتی** به‌جای اسپینرها.
- پیش‌جلب دارایی‌های احتمالی در حالت بیکار با `requestIdleCallback`.

<br />

### 11. تفاوت‌های فلسفی بین مدیریت حالت واکنشی (مثل MobX) و جریان داده یک‌طرفه (مثل Redux) چیست؟

| ویژگی       | MobX                         | Redux                          |
| ----------- | ---------------------------- | ------------------------------ |
| پارادایم   | مشاهده‌پذیر (فشار)          | یک‌طرفه (کشش)                |
| کد اولیه   | کم                          | بیشتر                         |
| اشکال‌زدایی | دشوارتر به دلیل به‌روزرسانی‌های مخفی | آسان‌تر به دلیل لاگ‌ها/سفر در زمان |

**Redux** برای پیش‌بینی‌پذیری بهتر است، **MobX** برای توسعه سریع و حالت محلی.

<br />

### 12. چگونه همگام‌سازی حالت را بین چندین تب یا پنجره مرورگر در یک برنامه React مدیریت می‌کنید؟

- استفاده از `BroadcastChannel`، رویدادهای `localStorage` یا **Service Workers**.

```jsx
window.addEventListener("storage", (e) => {
  if (e.key === "auth") syncAuth(e.newValue);
});

برای برنامه‌های حیاتی: استفاده از کارگران مشترک یا همگام‌سازی مبتنی بر indexedDB.


13. پیچیده‌ترین مشکل مدیریت حالت که حل کرده‌اید چیست و چه چیزی آن را چالش‌برانگیز کرد؟
سناریو: همکاری بلادرنگ با پشتیبانی آفلاین.
چالش‌ها:

حل تعارض (CRDTها)
همگام‌سازی حالت محلی/آفلاین
ادغام به‌روزرسانی‌های سرور بدون تکان رابط کاربری

راه‌حل: استفاده از صف مبتنی بر reducer سفارشی، indexedDB برای پایداری و رابط کاربری خوش‌بینانه با بازگشت.


14. درباره مرز بین حالت فرانت‌اند و حالت بک‌اند در یک سیستم توزیع‌شده چگونه فکر می‌کنید؟
فرانت‌اند:

حالت رابط کاربری/تجربه کاربری (مودال‌ها، فرم‌ها، انیمیشن‌ها)
داده‌های کش‌شده سرور (از طریق SWR/Query)

بک‌اند:

منبع حقیقت (احراز هویت، قوانین تجاری)

استفاده از React Query یا Apollo برای پل‌سازی، جداسازی واضح کش کلاینت از اقتدار سرور.


15. پیامدهای اتکای بیش‌ازحد به حالت جهانی در یک برنامه React چیست و چگونه از تبدیل شدن آن به یک ‘شیء خدا’ جلوگیری می‌کنید؟

دشواری در ردیابی اشکالات.
پیوستگی زیاد → "شیء خدا".
مانع استفاده مجدد از کامپوننت‌ها.

راه‌حل:

محلی‌سازی حالت در صورت امکان.
استفاده از برش‌های خاص دامنه یا ارائه‌دهندگان زمینه.
اجتناب از انتقال حالت جهانی به‌صورت عمیق.



16. چگونه ارزیابی می‌کنید که آیا یک ابزار یا کتابخانه جدید فرانت‌اند (مثل Vite، TanStack Query) ارزش پذیرش در کدبیس موجود را دارد؟
معیارها:

بلوغ و اکوسیستم (مستندات، مسائل)
مزایای تجربه توسعه در مقابل منحنی یادگیری
سازگاری با پشته موجود
مسیر انتشار: انتخابی یا مهاجرت کامل؟

مثال: برای پذیرش Vite:

بنچمارک ساخت‌های محلی (Vite 10 برابر سریع‌تر)
تست سازگاری افزونه‌ها
انتشار در هر ویژگی برای کاهش ریسک



17. نظر شما درباره تکامل باندلرهای جاوااسکریپت از Webpack به Vite و ESBuild چیست؟

Webpack: بسیار قابل تنظیم اما کندتر.
Vite: از ماژول‌های ES و پشتیبانی بومی مرورگر بهره می‌برد، HMR سریع.
ESBuild: فوق‌العاده سریع (مبتنی بر Go)، انعطاف‌پذیری کمتر.

نتیجه: Vite برای توسعه مدرن با بازخورد سریع ایده‌آل است. Webpack همچنان در برنامه‌های پیچیده و قدیمی غالب است.


18. چگونه تنش بین پذیرش فناوری‌های پیشرفته فرانت‌اند و اطمینان از پایداری در تولید را مدیریت می‌کنید؟
رویکرد:

رادار فناوری: دسته‌بندی ابزارها (پذیرش، آزمایش، نگه‌داری، ارزیابی).
انتشارهای کناری یا سوئیچ‌های انتخابی برای انتشار تدریجی.
مستندات و آموزش برای کاهش هزینه ورود.
تعادل بین بهره‌وری کوتاه‌مدت و قابلیت نگهداری بلندمدت.



19. مهم‌ترین محدودیت TypeScript در پروژه‌های بزرگ فرانت‌اند چیست و چگونه آن را دور می‌زنید؟
مشکل: پیچیدگی در تایپ‌های ژنریک پیشرفته و استنتاج در ماژول‌ها.
راه‌حل‌ها:

ترجیح عبارات تایپ ساده‌تر به‌جای پیچیده.
استفاده از تایپ‌های ابزار و JSDoc برای قراردادهای پیچیده.
مدولارسازی تایپ‌ها برای بهبود قابلیت نگهداری.



20. درباره نقش ابزارهای مبتنی بر هوش مصنوعی (مثل تولید کد، بهینه‌سازی خودکار) در آینده توسعه فرانت‌اند چگونه فکر می‌کنید؟
هوش مصنوعی برای موارد زیر عالی است:

ایجاد کد اولیه (فرم‌ها، پیکربندی)
تحلیل دسترسی‌پذیری
تولید تست
بررسی کد و تشخیص الگو

اما در موارد زیر ضعیف است:

تصمیم‌گیری‌های معماری
تجربه کاربری خاص دامنه

هوش مصنوعی نقش‌های ارشد فرانت‌اند را تقویت می‌کند، نه جایگزین. طراحی استراتژیک، ارتباط و تفکر سیستمی همچنان انسانی باقی می‌مانند.


21. چگونه اطمینان می‌دهید که دسترسی‌پذیری در یک چرخه توسعه سریع به‌عنوان یک فکر بعدی در نظر گرفته نشود؟
رویکرد:

جایگزینی در فرآیند: دسترسی‌پذیری (a11y) مانند پاسخ‌گویی یا تست در نظر گرفته می‌شود—اختیاری نیست.
استفاده از ابزارهای لینتینگ: ادغام افزونه‌های ESLint مثل jsx-a11y.
کامپوننت‌های قابل دسترس: ساخت یا استفاده از سیستم طراحی (مثل Radix، Headless UI) با دسترسی‌پذیری داخلی.
تست دستی: استفاده از ابزارهایی مثل axe DevTools، VoiceOver و ناوبری کیبورد به‌عنوان بخشی از بررسی PRها.

<button aria-label="بستن مودال">×</button>



22. سخت‌ترین چالش دسترسی‌پذیری که در یک برنامه React با آن مواجه شده‌اید چیست و چگونه آن را برطرف کردید؟
چالش: ایجاد یک منوی کشویی سفارشی قابل دسترس با کیبورد و سازگار با صفحه‌خوان.
راه‌حل:

استفاده از aria-expanded، aria-controls، role="menu" و role="menuitem".
مدیریت رویدادهای کیبورد (Enter، Esc، ArrowDown، ArrowUp).
استفاده از useEffect برای مدیریت تمرکز.
تست با صفحه‌خوان‌ها در پلتفرم‌های مختلف (NVDA، VoiceOver).



23. چگونه یک سیستم فرانت‌اند طراحی می‌کنید که در مرورگرهایی با سطوح مختلف پشتیبانی از ویژگی‌ها به‌زیبایی تنزل کند؟
رویکرد:

بهبود پیش‌رونده: شروع با HTML معنایی، افزودن بهبودهای JS در بالا.
تشخیص ویژگی: استفاده از @supports در CSS یا window.CSS.supports() در JS.

if ("IntersectionObserver" in window) {
  // استفاده از بارگذاری تنبل مدرن
} else {
  // پشتیبان: بارگذاری مشتاق یا رویدادهای اسکرول
}


پلی‌فیل‌ها: استفاده انتخابی از سرویس‌های پلی‌فیل مدرن (مثل core-js، polyfill.io).



24. موفقیت یک برنامه فرانت‌اند را فراتر از معیارهای فنی مثل زمان بارگذاری یا حجم باندل چگونه اندازه‌گیری می‌کنید؟
معیارهای کلیدی:

تعامل کاربر: ماندگاری، مدت‌زمان جلسه، کلیک‌ها.
نرخ تبدیل: اندازه‌گیری در مراحل خاص تجربه کاربری (مثل پرداخت).
موفقیت وظیفه: درصد کاربرانی که جریان‌های کاری حیاتی را کامل می‌کنند.
رعایت دسترسی‌پذیری: امتیاز ممیزی WCAG.
نرخ خطا: خطاهای اجرایی JS، مشکلات API 4xx/5xx.

استفاده از ابزارهایی مثل Amplitude، PostHog، Sentry و Google Lighthouse.


25. رویکرد شما برای ساخت یک فرانت‌اند که در وب احساس ‘بومی’ داشته باشد چیست و با چه معاوضه‌هایی مواجه می‌شوید؟
رویکرد:

اولویت‌بندی بازخورد فوری (ترنزیشن‌ها، تعاملات).
استفاده از قراردادهای پلتفرم: رفتار اسکرول، ورودی‌ها، ژست‌ها.
پذیرش ویژگی‌های بومی مرورگر مثل datalist، input[type="date"]، prefers-reduced-motion.

معاوضه‌ها:

برخی کامپوننت‌های با حس بومی (مثل انیمیشن‌ها) نیاز به پیچیدگی دارند.
تجربه کاربری چندپلتفرمی می‌تواند متفاوت باشد—اندروید در مقابل iOS در مقابل دسکتاپ.



26. چگونه یک سیستم احراز هویت فرانت‌اند طراحی می‌کنید که هم امن باشد و هم کاربرپسند؟
امن:

استفاده از کوکی‌های HttpOnly، SameSite برای جلوگیری از XSS/CSRF.
احراز هویت از طریق جریان‌های OAuth2/OIDC (مثل Auth0).
اعتبارسنجی توکن‌ها سمت سرور (عدم اعتماد به کلاینت).

کاربرپسند:

ارائه بازخورد واضح در مورد شکست‌های احراز هویت.
استفاده از احراز هویت بدون رمز یا بیومتریک در صورت امکان.
پشتیبانی از مدیریت انقضای جلسه به‌صورت زیبا.



27. ظریف‌ترین آسیب‌پذیری امنیتی که در یک برنامه فرانت‌اند با آن مواجه شده‌اید چیست و چگونه آن را کشف و برطرف کردید؟
مشکل: یک بردار XSS ذخیره‌شده در فیلد بیوگرافی پروفایل کاربر که از طریق dangerouslySetInnerHTML نمایش داده می‌شد.
رفع:

پاک‌سازی HTML با استفاده از DOMPurify قبل از رندرینگ.
ممیزی تمام نواحی محتوای پویا با تحلیل کد استاتیک.
جایگزینی dangerouslySetInnerHTML با رندرر مارک‌داون ایمن‌تر.



28. چگونه اطمینان می‌دهید که یک برنامه React در صورت خرابی یا تغییر غیرمنتظره وابستگی‌های شخص ثالث قابل اعتماد باقی می‌ماند؟
استراتژی‌های مقاومت:

کامپوننت‌های بسته‌بندی‌شده با پشتیبان‌ها (مثل اگر ویجت نقشه بارگذاری نشود).
تثبیت نسخه‌های وابستگی (package-lock، pnpm-lock.yaml).
استفاده از مرزهای خطا:

<ErrorBoundary fallback={<FallbackUI />}>
  <ThirdPartyComponent />
</ErrorBoundary>


نظارت بر APIهای خارجی با بررسی‌های سلامت اجرایی.



29. استراتژی شما برای مدیریت خطاهای فرانت‌اند در تولید در مقیاس چیست؟

استفاده از ابزارهای نظارت بر خطا (مثل Sentry، Bugsnag).
پیاده‌سازی مرزهای خطا برای گرفتن و ایزوله کردن خطاهای رندرینگ.
برچسب‌گذاری خطاها با زمینه کاربر/جلسه (ناشناس).
تجمیع، هشدار و اولویت‌بندی بر اساس فراوانی و تأثیر.



30. درباره تعامل بین امنیت فرانت‌اند و بک‌اند در یک برنامه تمام‌پشته چگونه فکر می‌کنید؟

فرانت‌اند محدودیت‌های سطح تجربه کاربری را اعمال می‌کند (مثل غیرفعال کردن دکمه‌ها، اعتبارسنجی پایه).
بک‌اند دروازه‌بان نهایی است: تمام ورودی‌ها باید اعتبارسنجی و مجاز شوند.
هرگز اسرار یا منطق احراز هویت را در کلاینت افشا نکنید.
استفاده از توکن‌های CSRF، محدودیت نرخ و اعتبارسنجی ورودی در هر دو طرف.



31. مهم‌ترین درسی که درباره رهبری تیم‌های فرانت‌اند آموخته‌اید و آرزو می‌کردید زودتر می‌دانستید چیست؟
درس: شفافیت از هوشمندی پیشی می‌گیرد.

کد خوانا و ساده بهتر از هک‌های هوشمند مقیاس می‌شود.
تشویق به مستندات و لاگ‌های تصمیم‌گیری.
توانمندسازی توسعه‌دهندگان تازه‌کار با مربی‌گری، نه دروازه‌بانی.



32. چگونه فرهنگی از آزمایش را در یک تیم فرانت‌اند پرورش می‌دهید و در عین حال استانداردهای بالای کیفیت را حفظ می‌کنید؟

استفاده از پرچم‌های ویژگی برای تست ایمن در تولید.
تشویق به شاخه‌های آزمایشی برای نمونه‌های اولیه.
جشن گرفتن یادگیری از آزمایش‌های ناموفق.
حفظ استانداردهای سخت‌گیرانه PR: حتی کدهای آزمایشی باید تست و بررسی شوند.



33. فلسفه شما درباره بدهی فنی در توسعه فرانت‌اند چیست؟
فلسفه:

همه بدهی‌ها بد نیستند—بدهی عمدی می‌تواند سرعت را بخرد.
ردیابی آن مثل اشکالات در بک‌لاگ.
برنامه‌ریزی اسپرینت‌های مهندسی برای پاک‌سازی.
استفاده از بررسی‌های کد برای جلوگیری از انباشت بدهی غیرعمدی.



34. چگونه تنش بین تحویل سریع ارزش تجاری و ساخت یک سیستم فرانت‌اند از نظر فنی عالی را مدیریت می‌کنید؟

ترجیح تحویل تدریجی: کوچک شروع کنید اما برای مقیاس طراحی کنید.
هم‌راستایی با محصول: نشان دهید چگونه معماری خوب ویژگی‌های سریع‌تر را در آینده امکان‌پذیر می‌کند.
حمایت از توسعه دو مسیره: کشف تجربه کاربری + مهندسی قبل از پیاده‌سازی.



35. بزرگ‌ترین مشکل حل‌نشده در توسعه فرانت‌اند امروز چیست و چگونه به حل آن می‌پردازید؟
مشکل: مدیریت حالت پایدار در مقیاس—تعادل بین حالت محلی، جهانی و سرور.
چرا دشوار است: نیازهای پیچیده رابط کاربری اغلب با عملکرد و سادگی در تضاد هستند.
رویکرد:

استفاده از ابزارهایی مثل Zustand، TanStack Query یا Recoil که کد اولیه حداقل و حالت محدود ارائه می‌دهند.
توسعه دستورالعمل‌های تیمی مشترک برای زمان/مکان ذخیره حالت (کامپوننت در مقابل زمینه در مقابل کش).
بلندمدت: سرمایه‌گذاری در ادغام‌های واکنشی بک‌اند (مثل اشتراک‌های GraphQL، TRPC) برای کاهش تکرار منطق حالت.



