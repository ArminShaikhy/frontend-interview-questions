### 1. چگونه یک فروشگاه Redux را برای یک برنامه React بزرگ‌مقیاس با چندین دامنه (مثل کاربر، محصول، سبد خرید) ساختاردهی می‌کنید؟

من از **ماژول‌سازی مبتنی بر ویژگی** پیروی می‌کنم و از **Redux Toolkit (RTK)** برای نگه داشتن اسلایس‌ها به‌صورت مجزا و مقیاس‌پذیر استفاده می‌کنم.

```bash
/src
  /store
    store.ts
  /features
    /کاربر
      userSlice.ts
      userSelectors.ts
    /محصول
      productSlice.ts
    /سبد_خرید
      cartSlice.ts

هر اسلایس اقدامات، ردیوسر و انتخابگرهای خود را مدیریت می‌کند. من آن‌ها را با استفاده از combineReducers ترکیب می‌کنم. این کار همکاری تیمی را امکان‌پذیر می‌کند، جفت‌سازی را کاهش می‌دهد و مرزهای دامنه واضحی را ترویج می‌دهد.


2. رویکرد شما برای مدیریت اقدامات ناهمزمان در Redux (مثل Redux Thunk در مقابل Redux Saga) چیست؟

من Redux Thunk را برای سادگی و مستقیم بودن ترجیح می‌دهم.
از Redux Saga برای جریان‌های کاری پیچیده، مثل شرایط رقابتی، لغو یا وظایف طولانی‌مدت استفاده می‌کنم.

مورد استفاده Saga: امتحان مجدد با بازگشت نمایی یا هماهنگی فراخوانی‌های زنجیره‌ای.


3. چگونه عملکرد Redux را برای جلوگیری از رندرهای غیرضروری در یک برنامه React بهینه می‌کنید؟

استفاده از انتخابگرهای مموایز شده از طریق reselect.
تقسیم حالت به اسلایس‌های ریزدانه برای کاهش جفت‌سازی.
استفاده از React.memo و useSelector با بررسی‌های برابری سطحی.
اجتناب از تودرتو کردن اشیاء بزرگ در حالت مگر اینکه نرمال‌سازی شده باشند.



4. پیچیده‌ترین ردیوسر Redux که نوشته‌اید چیست و چگونه اطمینان حاصل کردید که قابل پیش‌بینی و قابل آزمایش باقی بماند؟
من یک ردیوسر برای مدیریت یک جادوگر فرم چندمرحله‌ای با منطق شاخه‌ای و اعتبارسنجی ناهمزمان نوشتم.
برای حفظ پیش‌بینی‌پذیری:

منطق را به توابع خالص کمکی تقسیم کردم.
از الگوی ماشین حالت برای تعریف انتقال‌های مجاز استفاده کردم.
تست‌های واحد برای هر انتقال حالت با استفاده از Jest نوشتم.



5. چگونه یک برنامه Redux را وقتی تغییرات حالت غیرمنتظره رخ می‌دهد، اشکال‌زدایی می‌کنید؟

استفاده از Redux DevTools برای بررسی اقدامات ارسال‌شده و سفر در زمان.
لاگ کردن محموله‌های اقدام و تفاوت‌های حالت با میدلور.
جداسازی از طریق تست‌های واحد در منطق ردیوسر.
بررسی دوبار انتخابگرها برای جلوگیری از پروجکشن‌های داده قدیمی یا نادرست.



6. چگونه Redux را با TypeScript ادغام می‌کنید تا ایمنی نوع در اقدامات، ردیوسرها و انتخابگرها تضمین شود؟

استفاده از Redux Toolkit با createSlice و createAsyncThunk که به‌طور خودکار نوع‌ها را استنباط می‌کنند.
تعریف RootState تایپ‌شده و AppDispatch.
بهره‌برداری از ReturnType<typeof store.getState> برای استنباط نوع جهانی.



7. رویکرد شما برای نرمال‌سازی حالت در Redux برای یک برنامه داده‌محور (مثل فید رسانه اجتماعی) چیست؟

استفاده از createEntityAdapter از Redux Toolkit برای نرمال‌سازی داده‌ها.
ذخیره موجودیت‌ها در فرمت byId و استفاده از ids برای ترتیب.
انتخابگرها در زمان خواندن، غیرنرمال‌سازی را مدیریت می‌کنند.



8. چگونه میدلور Redux را برای نگرانی‌های متقاطع مثل لاگ‌گیری، تحلیل یا احراز هویت مدیریت می‌کنید؟

ایجاد میدلور سفارشی که نوع‌های اقدام خاص را رهگیری می‌کند.
استفاده از فیلدهای متا یا قراردادهای نام‌گذاری اقدام برای محدوده‌بندی اثرات.
برای تحلیل، در صورت نیاز رویدادها را محدود کرده و دسته‌بندی می‌کنم.



9. چگونه پایداری حالت Redux را در بارگذاری‌های مجدد صفحه یا راه‌اندازی مجدد برنامه مدیریت می‌کنید؟

استفاده از redux-persist برای سریال‌سازی اسلایس‌هایی مثل احراز هویت یا سبد خرید به localStorage.
فقط اسلایس‌های ضروری را در لیست سفید قرار می‌دهم.
استفاده از نسخه‌بندی و مهاجرت برای مدیریت ایمن تغییرات اسکیما.



10. استراتژی شما برای مهاجرت یک برنامه Redux قدیمی به یک راه‌حل مدیریت حالت مدرن چیست؟

معرفی Redux Toolkit به‌صورت تدریجی از طریق اسلایس‌ها.
مهاجرت ردیوسرهای قدیمی به createSlice.
جایگزینی سازندگان اقدام پرحجم با createAsyncThunk.
در صورت تغییر به Zustand/Recoil، ویژگی به ویژگی شروع کنید درحالی‌که از طریق زمینه یا پروکسی‌ها پل می‌زنید.



11. چگونه یک فروشگاه Zustand را برای یک برنامه React با چندین ویژگی ساختاردهی می‌کنید؟

استفاده از فروشگاه‌های ماژولار برای هر دامنه، که در صورت نیاز به یک فروشگاه مرکزی ترکیب می‌شوند.
نگه داشتن منطق در کنار ماژول‌های ویژگی برای انسجام.

برای حالت جهانی، چندین فروشگاه صادر می‌کنم و به‌صورت اختیاری آن‌ها را با میدلور Zustand ترکیب می‌کنم.


12. رویکرد شما برای مدیریت به‌روزرسانی‌های حالت ناهمزمان در Zustand چیست؟
استفاده از توابع ناهمزمان درون اقدامات. Zustand به‌طور مستقیم از ناهمزمان پشتیبانی می‌کند.
const useStore = create(set => ({
  fetchData: async () => {
    const data = await fetch('/api/داده').then(res => res.json());
    set({ data });
  }
}));

من از اثرات جانبی در کامپوننت‌ها اجتناب می‌کنم و اجازه می‌دهم فروشگاه منطق ناهمزمان را مالک باشد.


13. چگونه از سادگی Zustand برای بهبود بهره‌وری توسعه‌دهنده در یک محیط تیمی استفاده می‌کنید؟

بدون کد اولیه: مفاهیم کمتر، ورود آسان‌تر.
هم‌مکانی حالت، اقدامات و منطق ناهمزمان → تکرار سریع‌تر.
ادغام آسان با کامپوننت‌ها با استفاده از useStore.
نمونه‌سازی سریع بدون نیاز به ساختاردهی ردیوسرها/اقدامات.

نتیجه: بار شناختی کمتر، تحویل سریع‌تر ویژگی.


14. چگونه Zustand را با TypeScript ادغام می‌کنید تا حالت و اقدامات تایپ ایمن را تضمین کنید؟

تعریف یک رابط برای حالت و اقدامات.
استفاده از رابط در تعریف فروشگاه.

interface Store {
  count: number;
  increment: () => void;
}
const useStore = create<Store>(set => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 })),
}));



15. استراتژی شما برای پایداری حالت Zustand در جلسات یا تب‌ها چیست؟

استفاده از تابع persist از zustand/middleware با localStorage یا sessionStorage.
برای همگام‌سازی بین تب‌ها، استفاده از zustand/middleware/subscribeWithSelector + رویدادهای storage.

import { create } from 'zustand';
import { persist } from 'zustand/middleware';

const useStore = create(persist(
  set => ({
    data: {},
    setData: (data) => set({ data }),
  }),
  { name: 'ذخیره_برنامه' }
));



16. چگونه بین Redux و Zustand برای یک پروژه جدید React تصمیم می‌گیرید؟



معیار
استفاده از Redux
استفاده از Zustand



تیم بزرگ / الگوهای سخت‌گیرانه
✅
❌


ابزارهای توسعه جهانی، میدلور
✅
✅ (با راه‌اندازی)


راه‌اندازی حداقل / تکرار سریع
❌
✅


جریان‌های کاری پیچیده (مثل ساگا)
✅
❌


حالت کامپوننت محلی یا حالت گذرای UI
❌
✅


من Redux را زمانی انتخاب می‌کنم که نیاز به ساختار یا آشنایی تیمی باشد. Zustand برای برنامه‌های کوچک‌تر، نمونه‌سازی یا زمانی که Redux بیش از حد به نظر می‌رسد.


17. تفاوت‌های فلسفی بین حالت متمرکز و تغییرناپذیر Redux و حالت انعطاف‌پذیر و قابل تغییر Zustand چیست؟

Redux: بر پیش‌بینی‌پذیری از طریق تغییرناپذیری و ردیوسرهای خالص تأکید دارد. مناسب برنامه‌های بزرگ و مقیاس‌پذیر با الگوهای سخت‌گیرانه.
Zustand: سادگی و تغییر مستقیم را در بر می‌گیرد، عمل‌گرایی و راحتی توسعه‌دهنده را ترجیح می‌دهد.

Redux به رسمی بودن و ابزارسازی اهمیت می‌دهد؛ Zustand به سرعت و آزادی.


18. چگونه یک سیستم مدیریت حالت را طراحی می‌کنید که از یک نمونه اولیه کوچک به یک برنامه تولیدی با Redux یا Zustand مقیاس‌پذیر باشد؟

با Zustand برای سرعت و سادگی شروع کنید.
حالت و اقدامات را برای قابلیت ترکیب انتزاع کنید.
با افزایش پیچیدگی، سازمان ماژولار و میدلور را اتخاذ کنید.
اگر به‌طور قابل‌توجهی مقیاس‌پذیر شود (مشارکت‌کنندگان زیاد، ناهمزمان پیچیده)، مهاجرت تدریجی به Redux Toolkit یا استفاده از میدلور سفارشی Zustand برای اعمال نظم را در نظر بگیرید.



19. رویکرد شما برای آزمایش منطق مدیریت حالت در Redux در مقابل Zustand چیست؟
Redux:

تست واحد ردیوسرهای خالص و thunkهای ناهمزمان با ماک‌ها.
اسنپ‌شات انتقال‌های حالت پیچیده.
استفاده از redux-mock-store برای تست‌های یکپارچگی.

Zustand:

تست مستقیم متدهای فروشگاه.

test('increment increases count', () => {
  const store = create(set => ({
    count: 0,
    increment: () => set(state => ({ count: state.count + 1 })),
  }))();
  store.increment();
  expect(store.getState().count).toBe(1);
});

هر دو به‌راحتی قابل آزمایش هستند، اما سادگی Zustand امکان تکرار سریع بدون سربار تست را فراهم می‌کند.


20. چگونه یک تیم را درباره انتخاب و پیاده‌سازی کتابخانه‌های مدیریت حالت مثل Redux یا Zustand آموزش می‌دهید؟

با یک ماتریس تصمیم‌گیری سبک شروع کنید: آشنایی تیمی، پیچیدگی برنامه، نیازهای ابزارسازی.
برگزاری گفتگوهای فنی یا جلسات ناهار و یادگیری: پوشش مزایا و معایب و بهترین روش‌ها.
برنامه‌نویسی جفتی و بررسی‌های کد.
ارائه قالب‌های شروع (بویلرپلیت‌های Redux Toolkit یا Zustand).
تشویق به RFCها برای الگوهای جدید جهت اطمینان از پذیرش.

تیم را توانمند کنید تا انتخاب‌های آگاهانه انجام دهند، نه اینکه فقط روندها را دنبال کنند.```
