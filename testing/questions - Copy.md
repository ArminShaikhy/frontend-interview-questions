### 1. چگونه به تست کامپوننت‌های React نزدیک می‌شوید؟ از چه ابزارها یا کتابخانه‌هایی استفاده می‌کنید (مثل Jest، React Testing Library)؟

من بر تست **رفتار به جای پیاده‌سازی** تمرکز می‌کنم و از موارد زیر استفاده می‌کنم:

- **Jest** برای تست‌های واحد و یکپارچگی (اجراکننده سریع و قابل اعتماد).
- **React Testing Library (RTL)** برای تست تعامل مبتنی بر DOM که رفتار واقعی کاربر را شبیه‌سازی می‌کند.
- **MSW (Mock Service Worker)** برای ماک پاسخ‌های API.
- **Cypress یا Playwright** برای تست‌های پایان‌به‌پایان (E2E) که تعاملات واقعی مرورگر را شبیه‌سازی می‌کنند.

فلسفه من: تست کامپوننت‌ها به‌گونه‌ای که کاربران با آن‌ها تعامل می‌کنند — کلیک کردن، تایپ کردن و مشاهده خروجی‌ها — به جای حالت داخلی.

<br />

### 2. یک مورد تست ساده برای یک کامپوننت React که یک دکمه را رندر می‌کند و با کلیک، یک شمارنده را به‌روزرسانی می‌کند، بنویسید.

```jsx
// Counter.test.tsx
import { render, screen, fireEvent } from "@testing-library/react";
import Counter from "./Counter";

test("افزایش تعداد با کلیک", () => {
  render(<Counter />);
  fireEvent.click(screen.getByText(/افزایش/i));
  expect(screen.getByText(/تعداد: 1/i)).toBeInTheDocument();
});



3. تفاوت بین تست واحد و تست یکپارچگی در زمینه برنامه‌های React چیست؟

تست واحد: یک کامپوننت را به‌صورت مجزا تست می‌کند (مثل منطق، رندرینگ، رویدادهای کاربر).مثال: تست مدیریت‌کننده کلیک یک کامپوننت Button.
تست یکپارچگی: بررسی می‌کند که چگونه چندین کامپوننت با هم کار می‌کنند.مثال: تست یک فرم که داده‌ها را از طریق API ارسال می‌کند و پیام موفقیت را رندر می‌کند.

تست‌های واحد سریع‌تر و متمرکزتر هستند؛ تست‌های یکپارچگی برای جریان‌های دنیای واقعی اطمینان بیشتری فراهم می‌کنند.


4. چگونه یک فراخوانی API را در تست یک کامپوننت React ماک می‌کنید؟
من از MSW (Mock Service Worker) برای ماک واقعی API در سطح شبکه استفاده می‌کنم.
مثال:
import { rest } from "msw";
import { setupServer } from "msw/node";

const server = setupServer(
  rest.get("/api/کاربر", (req, res, ctx) => res(ctx.json({ name: "آلیس" })))
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

این کار تست‌ها را به رفتار برنامه در محیط تولید نزدیک نگه می‌دارد.


5. چگونه تست‌های واحد را برای یک کامپوننت React که به یک API خارجی وابسته است، ساختاردهی می‌کنید؟
من منطق API را از کامپوننت رابط کاربری جدا می‌کنم و هر دو را تست می‌کنم:

تست واحد مشتری API به‌صورت جداگانه (مثل getUser()).
در تست کامپوننت:
لایه API را ماک می‌کنم (مثل استفاده از MSW یا ماک Jest).
رفتار رابط کاربری را تست می‌کنم (مثل اسپینر بارگذاری، پیام خطا، رندر داده).



این جداسازی قابلیت اطمینان و وضوح تست را بهبود می‌بخشد.


6. یک تست یکپارچگی با استفاده از Cypress یا Playwright برای جریان ارسال فرم در React بنویسید.
// cypress/e2e/form_spec.cy.js
describe("فرم تماس", () => {
  it("فرم را با موفقیت ارسال می‌کند", () => {
    cy.visit("/تماس");
    cy.get('input[name="ایمیل"]').type("test@example.com");
    cy.get('textarea[name="پیام"]').type("سلام!");
    cy.intercept("POST", "/api/تماس", { statusCode: 200 }).as("ارسال_فرم");
    cy.get('button[type="submit"]').click();
    cy.wait("@ارسال_فرم");
    cy.contains("از شما برای تماس با ما تشکر می‌کنیم").should("be.visible");
  });
});



7. رویکرد شما برای تست پایان‌به‌پایان در یک برنامه React با چندین نقش کاربری چیست؟
من رفتار کاربر را بر اساس نقش‌ها (مثل مدیر در مقابل کاربر) شبیه‌سازی می‌کنم:

استفاده از Cypress یا Playwright برای ورود به‌عنوان نقش‌های مختلف از طریق رابط کاربری یا راه‌اندازی برنامه‌ریزی‌شده جلسه.
تست جریان‌های مبتنی بر نقش:
مدیر: دسترسی به داشبورد، مدیریت کاربران
کاربر: دسترسی محدود، مسیرهای محدودشده


پاسخ‌های احراز هویت را ماک کرده یا از حساب‌های تست آماده‌شده در محیط‌های تست استفاده می‌کنم.
موارد تست مبتنی بر نقش را سازمان‌دهی می‌کنم (مثل پوشه‌های admin/، user/).



8. چگونه اطمینان می‌دهید که پوشش تست معنادار باقی می‌ماند و نه فقط یک معیار برای دستیابی؟
من بر ارزش تست تمرکز می‌کنم، نه فقط اعداد:

هدف‌گذاری برای چگالی ادعای بالا — نه فقط خطوط "پوشش‌شده"، بلکه نتایج اعتبارسنجی‌شده.
اولویت‌بندی مسیرهای بحرانی: ارسال فرم، به‌روزرسانی‌های حالت، رندرینگ شرطی.
استفاده از ابزارهای پوشش کد (مثل -coverage در Jest) برای شناسایی شاخه‌های تست‌نشده — سپس تصمیم‌گیری که آیا ارزش تست دارند.
اجتناب از تست بیش از حد جزئیات پیاده‌سازی داخلی (مثل فراخوانی‌های setState).

بررسی‌های تست منظم و QA دستی به تقویت کیفیت فراتر از معیارها کمک می‌کنند.```
