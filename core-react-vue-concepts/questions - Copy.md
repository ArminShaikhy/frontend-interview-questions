### 1. DOM مجازی چیست و React چگونه از آن برای بهبود عملکرد استفاده می‌کند؟

DOM مجازی (VDOM) یک نمای سبک و درون‌حافظه‌ای از DOM واقعی است. React از آن برای بهینه‌سازی به‌روزرسانی‌ها و رندرینگ استفاده می‌کند.

هنگامی که حالت یا پراپ‌ها تغییر می‌کنند:

- React یک VDOM جدید رندر می‌کند.
- VDOM جدید را با نسخه قبلی مقایسه می‌کند (با استفاده از **الگوریتم تفاوت‌یابی**).
- مجموعه حداقل تغییرات (پچ‌ها) را محاسبه می‌کند.
- سپس DOM واقعی را به‌صورت **دسته‌ای** و کارآمد به‌روزرسانی می‌کند.

این کار دستکاری‌های مستقیم DOM که پرهزینه هستند را کاهش می‌دهد و عملکرد را بهبود می‌بخشد.

<br />

### 2. تفاوت بین کامپوننت‌های تابعی و کلاسی در React را توضیح دهید.

| جنبه           | کامپوننت کلاسی         | کامپوننت تابعی     |
| -------------- | ----------------------- | ------------------- |
| سینتکس        | کلاس‌های ES6           | توابع ساده JS      |
| حالت          | `this.state`           | هوک `useState`      |
| چرخه حیات     | `componentDidMount` و غیره | `useEffect`         |
| زمینه `this`   | مورد نیاز              | استفاده نمی‌شود     |

<br />

### 3. هوک‌های React چیستند؟ `useState`، `useEffect` و `useContext` را با مثال توضیح دهید.

هوک‌ها به کامپوننت‌های تابعی امکان مدیریت **حالت**، اثرات جانبی و زمینه را می‌دهند — ویژگی‌هایی که قبلاً فقط در کامپوننت‌های کلاسی در دسترس بودند.

- **`useState`**: حالت محلی را مدیریت می‌کند.
- **`useEffect`**: اثرات جانبی (جلب داده، اشتراک‌ها) را مدیریت می‌کند.
- **`useContext`**: به مقادیر زمینه دسترسی می‌یابد.

<br />

### 4. React چگونه روش‌های چرخه حیات کامپوننت را در کامپوننت‌های تابعی مدیریت می‌کند؟

کامپوننت‌های تابعی از **هوک‌ها** برای شبیه‌سازی رفتار چرخه حیات استفاده می‌کنند:

| چرخه حیات کلاسی       | معادل هوک                           |
| ---------------------- | ----------------------------------- |
| `componentDidMount`    | `useEffect(..., [])`                |
| `componentDidUpdate`   | `useEffect(..., [deps])`            |
| `componentWillUnmount` | `return () => {}` در داخل `useEffect` |

<br />

### 5. اهمیت کلیدها در لیست‌های React چیست و اگر به‌درستی استفاده نشوند چه اتفاقی می‌افتد؟

**کلیدها** به React کمک می‌کنند تا تشخیص دهد کدام آیتم‌ها در یک لیست تغییر کرده، اضافه شده یا حذف شده‌اند. کلیدها باید **منحصربه‌فرد و پایدار** باشند.

اگر از ایندکس‌ها به‌عنوان کلید استفاده کنید یا آن‌ها را حذف کنید:

- React ممکن است کامپوننت‌ها را به‌غلط بازاستفاده کند.
- این می‌تواند باعث اشکالات رندرینگ یا عملکرد ضعیف شود.

<br />

### 6. تفاوت‌های کلیدی بین React.js و Vue.js از نظر معماری کامپوننت و واکنش‌پذیری چیست؟

| ویژگی           | React                           | Vue                           |
| --------------- | ------------------------------- | ----------------------------- |
| زبان            | JSX + JS                        | قالب‌های HTML + JS           |
| واکنش‌پذیری     | حالت غیرقابل تغییر، به‌روزرسانی دستی | ارجاعات و پراکسی‌های واکنشی |
| مدل کامپوننت    | اولویت تابعی با هوک‌ها         | API گزینه‌ها / API ترکیب     |
| اتصال داده      | یک‌طرفه                       | دوطرفه از طریق `v-model`     |
| مدیریت حالت     | Context، Redux، Zustand         | Vuex، Pinia                   |

React بیشتر **بدون نظر خاص** است (آزادی، انعطاف‌پذیری)، در حالی که Vue تجربه توسعه‌دهنده‌ای **کامل‌تر** ارائه می‌دهد.

<br />

### 7. چگونه تصمیم می‌گیرید که برای یک پروژه جدید از React.js یا Vue.js استفاده کنید؟ چه عواملی بر انتخاب شما تأثیر می‌گذارند؟

**عوامل:**

- **تجربه تیم** (React در شرکت‌های بزرگ رایج‌تر است).
- **نیازهای اکوسیستم** (مثل Next.js در مقابل Nuxt).
- **پیچیدگی پروژه** (سادگی Vue برای برنامه‌های کوچک تا متوسط مناسب است).
- **ترجیح ابزارها** (React: انعطاف‌پذیر، Vue: یکپارچه‌تر).
- **پشتیبانی جامعه** و **بازار کار** (React پذیرش گسترده‌تری دارد).

**قانون کلی:**

- برای رابط‌های کاربری بزرگ‌مقیاس، بلندمدت و قابل سفارشی‌سازی → React.
- برای برنامه‌های سریع‌الوصول یا تیم‌هایی با عمق کمتر در JS → Vue.

<br />

### 8. چگونه یک برنامه قدیمی React را از کامپوننت‌های کلاسی به کامپوننت‌های تابعی با هوک‌ها مهاجرت می‌کنید؟

**رویکرد گام‌به‌گام:**

1. با کامپوننت‌های ایزوله و کم‌ریسک شروع کنید.
2. `state` را با `useState` جایگزین کنید.
3. روش‌های چرخه حیات را با `useEffect` جایگزین کنید.
4. اتصالات را با حذف `this` مدیریت کنید.
5. مصرف‌کننده‌های زمینه را با استفاده از `useContext` مهاجرت کنید.

<br />

### 9. کامپوننت‌های مرتبه بالاتر (HOCs) چیستند؟ مثالی از زمانی که از یکی استفاده کرده‌اید ارائه دهید.

HOC یک **تابع است که یک کامپوننت را می‌گیرد و یک کامپوننت جدید** با رفتار بهبودیافته بازمی‌گرداند. این یک الگو برای استفاده مجدد از کد است.

**مورد استفاده:**
من از HOCها برای موارد زیر استفاده کرده‌ام:

- تزریق منطق سراسری (مثل ثبت وقایع، مرزهای خطا).
- افزودن بررسی‌های احراز هویت به مسیرها.
- اتصال کامپوننت‌ها به Redux (مثل `connect()`).

<br />

### 10. چگونه ترکیب پیچیده کامپوننت‌ها را در React.js یا Vue.js مدیریت می‌کنید تا از کد به‌هم‌پیوسته جلوگیری کنید؟

**استراتژی‌ها:**

- استفاده از **کامپوننت‌های ترکیبی** برای زمینه مشترک و رفتار شبه‌اسلات.
- استفاده از **پراپ‌های رندر** یا **هوک‌های سفارشی** برای استفاده مجدد از منطق.
- جداسازی UI و منطق (الگوی کامپوننت هوشمند/خام).
- اجتناب از دریلینگ پراپ‌ها از طریق **زمینه** یا **provide/inject** در Vue.

<br />

### 11. تطبیق React چیست و چگونه در پشت صحنه کار می‌کند؟

تطبیق فرآیند استفاده شده توسط React برای به‌روزرسانی DOM هنگام تغییر حالت یا پراپ‌های یک کامپوننت است.

مراحل:

1. تغییر حالت یک **درخت VDOM جدید** ایجاد می‌کند.
2. React آن را با درخت قبلی با استفاده از **الگوریتم هیوریستیک** (O(n)) مقایسه می‌کند.
3. تغییرات حداقل را شناسایی کرده و DOM واقعی را به‌روزرسانی می‌کند.

**بهینه‌سازی‌های کلیدی:**

- استفاده از **کلیدها** برای تشخیص تغییرات لیست.
- فرض می‌کند کامپوننت‌هایی با نوع یکسان خروجی مشابهی تولید می‌کنند.
- استفاده از معماری **Fiber** برای رندرینگ ناهمزمان و اولویت‌بندی.

این باعث می‌شود به‌روزرسانی‌ها قابل پیش‌بینی و کارآمد باشند، به‌ویژه در رابط‌های کاربری بزرگ.

