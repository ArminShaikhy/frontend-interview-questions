### 1. چگونه مدل شیء سند HTML (DOM) و رابطه آن با DOM مجازی React را مفهوم‌سازی می‌کنید؟

**DOM** نمای درختی زنده مرورگر از سند HTML است. دستکاری مستقیم آن به دلیل بازچیدمان‌ها/بازنقاشی‌ها پرهزینه است.

React **DOM مجازی (VDOM)** را به‌عنوان نمای سبک در حافظه از DOM معرفی می‌کند. در هنگام تغییر حالت:

- React **تفاوت** بین درخت‌های VDOM قبلی و بعدی را محاسبه می‌کند.
- عملیات واقعی DOM را با استفاده از تطبیق **دسته‌بندی و به حداقل می‌رساند**.

```jsx
useState باعث رندر مجدد می‌شود → تفاوت VDOM → به‌روزرسانی‌های حداقلی DOM

این مدل عملکرد را بهبود می‌بخشد و رابط‌های کاربری اعلانی را امکان‌پذیر می‌کند.


2. مدل ذهنی شما برای ساختاردهی HTML معنایی در یک چارچوب مبتنی بر کامپوننت مثل React چیست؟
معناشناسی باید ساختار را هدایت کند، حتی در داخل کامپوننت‌ها. من نقش‌ها و نیت‌ها را به تگ‌های مناسب (<nav>، <main>، <section>، <article>) نگاشت می‌کنم.
مثال:
function BlogPost({ title, content }) {
  return (
    <article>
      <h2>{title}</h2>
      <section>{content}</section>
    </article>
  );
}

از سوپ div اجتناب می‌کنم و کامپوننت‌ها را به‌عنوان بسته‌بندی‌های معنایی در نظر می‌گیرم و در صورت امکان از تگ‌های HTML5 استفاده می‌کنم. این دسترسی‌پذیری و سئو را بهبود می‌بخشد.


3. درباره تعامل بین ویژگی‌های HTML (مثل data-*، aria-*) و پراپ‌های React چگونه فکر می‌کنید؟
React ویژگی‌های استاندارد HTML و ویژگی‌های خاص (aria-*، data-*) را به‌عنوان پراپ‌هایی که به گره DOM منتقل می‌شوند در نظر می‌گیرد.
<button aria-label="بستن" data-testid="دکمه-بستن">
  X
</button>


data-*: برای تست، تحلیل یا هوک‌های رفتاری.
aria-*: برای دسترسی‌پذیری (پشتیبانی از صفحه‌خوان).
هر دو در JSX شهروندان درجه یک هستند و باید با دقت مدیریت شوند.



4. چگونه ساختار HTML را برای پشتیبانی از یک رابط کاربری پیچیده و تودرتو (مثل منوی ناوبری چندسطحی) طراحی می‌کنید و در عین حال قابلیت نگهداری را حفظ می‌کنید؟
رویکرد:

استفاده از تگ‌های معنایی: <nav>، <ul>، <li> و نقش‌های ARIA در صورت نیاز.
رندر بازگشتی داده‌های تودرتو.
نگه داشتن کامپوننت‌ها به‌صورت اتمیک.

function NavItem({ label, children }) {
  return (
    <li>
      {label}
      {children && <ul>{children.map(...</ul>}
    </li>
  );
}

نگرانی‌ها (مثل ارائه در مقابل منطق) را جدا می‌کنم و ناوبری کیبورد و دسترسی‌پذیری را تضمین می‌کنم.


5. رویکرد شما برای مدل‌سازی فرم‌های HTML در یک برنامه React، به‌ویژه برای اعتبارسنجی و ارسال چیست؟
از کامپوننت‌های کنترل‌شده برای حالت قابل پیش‌بینی استفاده می‌کنم:
const [email, setEmail] = useState("");
<input value={email} onChange={(e) => setEmail(e.target.value)} />;

برای اعتبارسنجی:

استفاده از Yup/Zod + React Hook Form یا منطق سفارشی.
اعتبارسنجی درون‌خطی در هنگام blur/change.
جلوگیری از پیش‌فرض در ارسال، مدیریت ایمن اقدامات ناهمزمان.

<form onSubmit={handleSubmit(onSubmit)} />



6. درباره تأثیر تجزیه و رندرینگ HTML بر عملکرد بارگذاری صفحه چگونه استدلال می‌کنید؟
مسیر رندرینگ بحرانی تحت تأثیر قرار می‌گیرد:

اندازه HTML: DOM بزرگ‌تر = تجزیه و رندر کندتر.
منابع مسدودکننده: اسکریپت‌های همگام تجزیه DOM را به تأخیر می‌اندازند.
عمق DOM: درخت‌های عمیق = پیچیدگی بیشتر بازچیدمان/بازنقاشی.

بهینه‌سازی با:

کاهش بار HTML اولیه (مثل بارگذاری تنبل رابط کاربری غیربحرانی).
اولویت‌بندی ترتیب محتوا (بالای صفحه).
استفاده از SSR/Streaming برای برتری در زمان اولین بایت.



7. مدل ذهنی شما برای مدیریت رویدادهای HTML در یک برنامه React در مقایسه با جاوااسکریپت خام چیست؟
در React:

رویدادها ترکیبی هستند: برای سازگاری بین‌مرورگری بسته‌بندی شده‌اند.
مانند رویدادهای بومی حباب می‌کنند اما با سیستم واگذاری React (در ریشه).

<button onClick={handleClick}>کلیک کنید</button>

مزایا:

رفتار یکنواخت.
مدیریت آسان‌تر حافظه.
به‌روزرسانی‌های دسته‌ای.

در جاوااسکریپت خام:

شنونده‌ها مستقیماً به عناصر اضافه می‌شوند.
نیاز به پاک‌سازی دستی.

React چرخه حیات و عملکرد را ساده می‌کند.


8. چگونه ساختارهای HTML را برای پشتیبانی از بهبود پیش‌رونده در یک برنامه مبتنی بر React طراحی می‌کنید؟
HTML را ابتدا برای کار بدون جاوااسکریپت می‌سازم، سپس با React بهبود می‌دهم.
مثال:

رندر HTML با SSR با لینک‌ها و دکمه‌های کاربردی.
هیدراتاسیون در کلاینت برای تعامل غنی‌تر (مثل مودال‌ها، جستجو).

استفاده از:

HTML معنایی
پیام‌های پشتیبان <noscript>
رویکرد دسترسی‌پذیری‌محور (ناوبری کیبورد، فوکوس قابل مشاهده)

<button type="submit">جستجو</button>

بهبود شامل افزودن فیلترها، انیمیشن‌ها و غیره پس از هیدراتاسیون است.


9. درباره نقش HTML در یک برنامه React رندرشده سمت سرور (SSR) چگونه فکر می‌کنید؟
HTML در SSR رندر اولیه تحویل‌شده به مرورگر است:

زمان اولین رنگ‌آمیزی (TTFP) و سئو را بهبود می‌بخشد.
React HTML را به یک اپلیکیشن زنده هیدراته می‌کند.

مدلم:

نگه داشتن نشانه‌گذاری معنایی و حداقلی برای SSR.
استفاده از تگ‌های <head> برای متا، عنوان، پیش‌بارگذاری (از طریق react-helmet یا @vitejs/plugin-react).
اجتناب از رندرینگ غیرقطعی (مثل window، localStorage در سرور).



10. مدل ذهنی شما برای مدیریت متادیتای HTML (مثل <meta>، <link>) در یک برنامه تک‌صفحه‌ای (SPA) چیست؟
متادیتا را به‌عنوان بخشی از زمینه مسیر دینامیک در نظر می‌گیرم. برای SPAها:

استفاده از react-helmet یا @tanstack/router برای تنظیم اعلانی <title>، <meta> و غیره.
در هنگام تغییر مسیر، سربرگ را برای سئو + اشتراک‌گذاری اجتماعی به‌روزرسانی کنید.

<Helmet>
  <title>صفحه محصول</title>
  <meta name="description" content="جزئیات درباره محصول" />
</Helmet>

برای PWAها، مدیریت <link rel="manifest">، آیکون‌ها و نکات پیش‌بارگذاری نیز انجام می‌شود.```
