### 1. مقایسه Webpack، Vite و ESBuild از نظر سرعت، پیکربندی و موارد استفاده. کدام را برای یک پروژه React انتخاب می‌کنید و چرا؟

| ویژگی         | Webpack                                         | Vite                                               | ESBuild                                   |
| ------------- | ----------------------------------------------- | -------------------------------------------------- | ----------------------------------------- |
| **سرعت**     | کندتر (به‌ویژه در بازسازی‌ها)                 | سرور توسعه بسیار سریع با استفاده از ESM بومی + ESBuild | سریع‌ترین برای باندلینگ، مجموعه ویژگی‌های محدود |
| **پیکربندی** | بسیار قابل تنظیم، پیچیده                       | پیکربندی حداقل (پیش‌فرض‌های منطقی)               | سبک، اما افزونه‌های محدود                |
| **موارد استفاده** | برنامه‌های بزرگ و بالغ که نیاز به سفارشی‌سازی عمیق دارند | برنامه‌های تک‌صفحه‌ای مدرن که نیاز به تجربه توسعه سریع دارند | ابزارها، کتابخانه‌ها یا پیش‌باندلرها     |

**کدام برای React؟**

> برای پروژه‌های مدرن React، Vite انتخاب ترجیحی من است. این ابزار با استفاده از ESM بومی، راه‌اندازی بسیار سریعی ارائه می‌دهد، به‌خوبی با React + TypeScript ادغام می‌شود و تجربه توسعه (DX) را نسبت به Webpack به‌طور قابل‌توجهی بهبود می‌بخشد. برای برنامه‌های قدیمی بزرگ، Webpack همچنان اکوسیستم افزونه‌های گسترده‌تر و کنترل دقیق‌تری ارائه می‌دهد.

<br />

### 2. چگونه یک پیکربندی سفارشی Webpack را برای یک برنامه React با TypeScript و پیش‌پردازش CSS تنظیم می‌کنید؟

به موارد زیر نیاز دارید:

- `webpack.config.js`
- Babel برای تبدیل JSX/TS
- لودرها برای `.tsx`، `.css` و پیش‌پردازنده‌ها

```jsx
// webpack.config.js
module.exports = {
  entry: "./src/index.tsx",
  output: { filename: "bundle.js", path: __dirname + "/dist" },
  resolve: { extensions: [".ts", ".tsx", ".js"] },
  module: {
    rules: [
      { test: /\\.tsx?$/, use: "babel-loader", exclude: /node_modules/ },
      { test: /\\.s?css$/, use: ["style-loader", "css-loader", "sass-loader"] },
    ],
  },
  devServer: { historyApiFallback: true },
};

نصب babel-loader، @babel/preset-react، @babel/preset-typescript و پیکربندی .babelrc.
این پیکربندی از React + TypeScript و SCSS پشتیبانی می‌کند و برای معماری‌های前端 مقیاس‌پذیر ایده‌آل است.


3. مزایای استفاده از Vite نسبت به Webpack در یک پروژه مدرن React چیست؟

راه‌اندازی سریع‌تر: بدون باندلینگ در حالت توسعه. استفاده از ESM بومی + ESBuild برای HMR لحظه‌ای.
پیکربندی ساده: حداقل کدهای اولیه. افزونه React از طریق @vitejs/plugin-react.
پشتیبانی آماده: JSX، TypeScript، CSS Modules، PostCSS.
ساخت‌های تولیدی: همچنان از Rollup در پشت صحنه برای بهینه‌سازی tree-shaking استفاده می‌کند.



4. چگونه فرآیند ساخت را بهینه می‌کنید تا زمان استقرار در خط لوله CI/CD کاهش یابد؟

فعال‌سازی کش:
استفاده از webpack.cache (در حافظه یا سیستم فایل).
بهره‌گیری از کش CI (مثل node_modules، dist، کش‌های turbo، vite).


موازی‌سازی:
استفاده از لودرهای چندنخی (thread-loader، Vite این کار را به‌صورت پیش‌فرض انجام می‌دهد).
تقسیم ساخت‌ها به کارهای کوچک‌تر (مثل کلاینت در مقابل سرور).


Tree-shaking + تقسیم کد:
حذف کد مرده.
واردسازی پویای مسیرها/کامپوننت‌ها.


استفاده از ابزارهای سبک:
تغییر به Vite یا ESBuild برای توسعه سریع‌تر و خروجی کوچک‌تر.


حذف وابستگی‌های بزرگ:
بررسی حجم باندل با webpack-bundle-analyzer یا source-map-explorer.


ساخت‌های افزایشی:
ابزارهایی مانند Nx یا Turborepo امکان کش و بازسازی فقط بسته‌های تغییر یافته را فراهم می‌کنند.





5. زمانی را توصیف کنید که مجبور شدید یک مشکل مرتبط با باندلر را در یک برنامه React اشکال‌زدایی کنید.
در پروژه‌ای قبلی، یک برنامه React که از Webpack استفاده می‌کرد، در محیط تولید خطاهای اجرایی ایجاد می‌کرد — در حالی که در حالت توسعه کار می‌کرد. پس از بررسی، متوجه شدم:

خطا به دلیل حذف یک ماژول با اثر جانبی در tree-shaking بود که به‌درستی علامت‌گذاری نشده بود.
یک کتابخانه شخص ثالث در زمان واردسازی اثر جانبی داشت که در ساخت فشرده حذف شده بود.

مراحل انجام شده:

فعال‌سازی انتخابی sideEffects: false در package.json.
استفاده از webpack-bundle-analyzer برای تجسم ماژول گمشده.
افزودن نکات /*#__PURE__*/ برای ماژول‌های ابزار سفارشی برای کمک به tree-shaking ایمن.
ارتقاء پیکربندی Webpack برای اطمینان از چانکینگ قطعی و تولید نقشه منبع برای اشکال‌زدایی آسان‌تر.

نتیجه: ساخت تولیدی پایدار، کوچک‌تر و آسان‌تر برای اشکال‌زدایی در آینده شد.```
