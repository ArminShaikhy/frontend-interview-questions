### 1. حلقه رویداد جاوااسکریپت چگونه کار می‌کند و چگونه بر رندرینگ و به‌روزرسانی‌های حالت در React تأثیر می‌گذارد؟

حلقه رویداد به جاوااسکریپت (تک‌رشته‌ای) اجازه می‌دهد عملیات **ناهمزمان** را با استفاده از **پشته فراخوانی**، **صف وظایف (ماکروتسک‌ها)** و **صف میکروتسک‌ها** مدیریت کند.

در React:

- `setState` **دسته‌ای و ناهمزمان** است.
- به‌روزرسانی‌های حالت و رندرینگ **پس از خالی شدن پشته فراخوانی فعلی** انجام می‌شوند (به‌صورت میکروتسک یا ماکروتسک بسته به زمینه در صف قرار می‌گیرند).
- درک این موضوع به جلوگیری از شرایط رقابتی و اطمینان از به‌روزرسانی‌های قابل پیش‌بینی رابط کاربری کمک می‌کند.

<br />

### 2. مدل ذهنی شما برای درک بسته‌های جاوااسکریپت (Closures) چیست و چگونه از آن‌ها به‌طور مؤثر در یک برنامه React استفاده می‌کنید؟

بسته یک تابع است که **به محدوده لغوی خود دسترسی حفظ می‌کند**، حتی زمانی که خارج از آن محدوده فراخوانی شود.

در React:

- برای **کال‌بک‌های مموایز شده** یا مدیریت **حالت کپسوله‌شده** در هوک‌های سفارشی مفید است.

```jsx
function useCounter() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1); // بسته روی `count`
  return { count, increment };
}

بسته‌ها باید در افکت‌ها با دقت مدیریت شوند تا از مشکلات حالت قدیمی جلوگیری شود.


3. وراثت پروتوتایپی در جاوااسکریپت را چگونه توضیح می‌دهید و چگونه با وراثت کلاسیک متفاوت است؟
وراثت پروتوتایپی اشیاء را از طریق زنجیره [[Prototype]] به یکدیگر متصل می‌کند و امکان اشتراک‌گذاری ویژگی‌ها را فراهم می‌کند.
برخلاف وراثت کلاسیک:

جاوااسکریپت واگذاری شیء را به سلسله‌مراتب کلاسی ترجیح می‌دهد.
پویاتر و انعطاف‌پذیرتر است، که به‌خوبی با الگوهای ترکیبی در React هم‌راستا می‌شود.



4. اهمیت کلمه کلیدی this در جاوااسکریپت چیست و چگونه اتصال آن را در کامپوننت‌های React مدیریت می‌کنید؟
this به زمینه اجرا اشاره دارد. در کامپوننت‌های کلاسی React، this اغلب به نمونه کامپوننت اشاره می‌کند.
در کامپوننت‌های کلاسی:
constructor() {
  this.handleClick = this.handleClick.bind(this);
}

در کامپوننت‌های تابعی:

کاملاً از this اجتناب کنید و از هوک‌ها و توابع فلش استفاده کنید.
توابع فلش به‌صورت لغوی this را متصل می‌کنند.



5. ماهیت تک‌رشته‌ای جاوااسکریپت چگونه بر رویکرد شما برای مدیریت وظایف محاسباتی سنگین در یک برنامه React تأثیر می‌گذارد؟
از آنجا که جاوااسکریپت روی یک رشته واحد اجرا می‌شود، وظایف سنگین رابط کاربری را مسدود می‌کنند.
استراتژی‌ها:

Web Workers برای انتقال کارهای سنگین CPU.
محدود کردن/تأخیر دادن ورودی‌ها.
استفاده از requestIdleCallback یا setTimeout برای به تعویق انداختن کار.
نگه داشتن کامپوننت‌ها خالص و سریع‌رندر.



6. چگونه یک جریان کاری قوی async/await در یک برنامه React برای مدیریت چندین فراخوانی API طراحی می‌کنید؟
استفاده از async/await در useEffect، کپسوله‌شده در try/catch، و به‌صورت اختیاری استفاده از Promise.all.
useEffect(() => {
  const fetchData = async () => {
    try {
      const [users, posts] = await Promise.all([
        fetch("/api/کاربران").then(res => res.json()),
        fetch("/api/پست‌ها").then(res => res.json()),
      ]);
      setData({ users, posts });
    } catch (error) {
      setError(error);
    }
  };
  fetchData();
  return () => { /* پاک‌سازی */ };
}, []);



7. تفاوت بین Promises و async/await در پشت صحنه چیست و چگونه استفاده آن‌ها را در React بهینه می‌کنید؟

Promises مقادیر ناهمزمان را نشان می‌دهند؛ then کال‌بک‌ها را زنجیره می‌کند.
async/await شکر نحوی روی Promises است که خوانایی و اشکال‌زدایی را بهبود می‌بخشد.

بهینه‌سازی‌ها:

اجتناب از await تودرتو در حلقه‌ها (استفاده از Promise.all).
مموایز کردن توابع ناهمزمان با useCallback.
همیشه پاک‌سازی را در افکت‌های ناهمزمان مدیریت کنید تا از شرایط رقابتی جلوگیری شود.



8. چگونه یک ابزار مبتنی بر Promise سفارشی (مثل مکانیزم امتحان مجدد) را برای یک برنامه React پیاده‌سازی می‌کنید؟
const retry = (fn, retries = 3, delay = 1000) =>
  fn().catch((err) => {
    if (retries === 0) throw err;
    return new Promise((res) => setTimeout(res, delay)).then(() =>
      retry(fn, retries - 1, delay)
    );
  });



9. رویکرد شما برای مدیریت میکروتسک‌ها و ماکروتسک‌ها در یک برنامه React با عملیات ناهمزمان سنگین چیست؟

میکروتسک‌ها: Promises، queueMicrotask.
ماکروتسک‌ها: setTimeout، fetch.

استفاده از میکروتسک‌ها برای زنجیره‌بندی منطق و ماکروتسک‌ها برای به تعویق انداختن اجرا.


10. چگونه از پروتکل تکرارگر ناهمزمان (مثل for await...of) در یک برنامه React برای داده‌های جریانی استفاده می‌کنید؟
برای APIهای جریانی (مثل SSE، تکه‌های فایل) استفاده می‌شود:
async function streamData(url) {
  const response = await fetch(url);
  for await (const chunk of response.body) {
    processChunk(chunk);
  }
}

در React:

در useEffect اجرا شود.
برای فیدهای بلادرنگ یا دانلودهای طولانی مفید است.



11. چگونه از ماژول‌های ES6 در یک کدبیس بزرگ React برای اطمینان از قابلیت نگهداری و حذف کد غیرضروری استفاده می‌کنید؟

استفاده از صادرات نام‌گذاری‌شده برای حذف بهتر کد غیرضروری.
ساختاردهی ویژگی‌ها به‌عنوان پوشه‌های مجزا با یک index.ts برای صادرات بشکه‌ای.
اجتناب از صادرات پیش‌فرض در کتابخانه‌های مشترک برای کمک به تحلیل استاتیک.



12. درک شما از محدوده و بالاکشی (Hoisting) جاوااسکریپت چیست و چگونه از مشکلات رایج در React جلوگیری می‌کنید؟
پاسخ:

محدوده: لغوی—در زمان نوشتن تعیین می‌شود.
بالاکشی: اعلان‌های var و توابع بالاکشیده می‌شوند.

در React:

استفاده از let/const برای جلوگیری از اشکالات بالاکشی.
اجتناب از تکیه بر متغیرهای بالاکشیده در بسته‌ها یا هوک‌ها.
نگه داشتن اعلان‌های متغیر درون محدوده هوک/کامپوننت.



13. چگونه یک کتابخانه ابزار جاوااسکریپت برای یک تیم React طراحی می‌کنید که تعادل بین کپسوله‌سازی و استفاده مجدد را حفظ کند؟
پاسخ:

استفاده از توابع خالص.
سازمان‌دهی بر اساس دامنه (مثل formatters/، validators/).
نوشتن تایپ‌های TypeScript و JSDoc واضح.
اجتناب از حالت داخلی یا اثرات جانبی.
ارائه پیکربندی‌های پیش‌فرض اما امکان بازنویسی.



14. چگونه اصول برنامه‌نویسی تابعی (مثل تغییرناپذیری، توابع خالص) را در یک برنامه React اعمال می‌کنید؟

استفاده از map، filter و reduce برای تبدیل داده.
اجتناب از تغییر حالت (مثل عملگرهای پخش).
استخراج کمکی‌های خالص برای انتخابگرها و منطق کسب‌وکار.
کتابخانه‌ها: Lodash/fp، Ramda (در صورت نیاز).



15. رویکرد شما برای مموایز کردن محاسبات سنگین در جاوااسکریپت برای یک برنامه React چیست؟
استفاده از useMemo:
const filtered = useMemo(() => heavyFilter(data), [data]);

اجتناب از بهینه‌سازی زودهنگام؛ ابتدا پروفایل کنید. اطمینان از صحت وابستگی‌ها برای جلوگیری از مقادیر قدیمی یا بازمحاسبه‌شده.


16. چگونه عملکرد جاوااسکریپت را در یک برنامه React با به حداقل رساندن تغییرات شیء بهینه می‌کنید؟

استفاده از به‌روزرسانی‌های تغییرناپذیر (مثل عملگرهای پخش، immer).
اجتناب از مرتب‌سازی درجا یا افزودن به آرایه‌ها.
به React کمک می‌کند تغییرات را از طریق مقایسه سطحی (React.memo، PureComponent) تشخیص دهد.



17. چگونه از Proxy یا Reflect جاوااسکریپت در یک برنامه React برای مدیریت حالت پویا یا اشکال‌زدایی استفاده می‌کنید؟
استفاده از Proxy برای ردیابی تغییرات یا ساخت بسته‌بندی‌های واکنشی:
const state = new Proxy(
  {},
  {
    set(target, key, value) {
      console.log(`${key} به ${value} تغییر کرد`);
      target[key] = value;
      return true;
    },
  }
);

مناسب برای اشکال‌زدایی، کتابخانه‌های فرم یا مشاهده‌پذیرهای سفارشی.


18. درک شما از جمع‌آوری زباله جاوااسکریپت چیست و چگونه از نشت‌های حافظه در یک برنامه React جلوگیری می‌کنید؟
جاوااسکریپت از جمع‌آوری زباله علامت‌گذاری و جاروب استفاده می‌کند. نشت‌های حافظه زمانی رخ می‌دهند که اشیاء به‌طور ناخواسته ارجاع می‌مانند.
در React:

پاک‌سازی در useEffect.
اجتناب از refs قدیمی یا نگه داشتن گره‌های DOM در بسته‌ها.
نظارت بر نشت‌ها با استفاده از تب Memory در Chrome DevTools.



19. چگونه مشکلات دقت اعداد اعشاری جاوااسکریپت را در یک برنامه React (مثل محاسبات مالی) مدیریت می‌کنید؟
از اعداد اعشاری بومی برای پول اجتناب کنید. استفاده از:

Intl.NumberFormat برای نمایش.
Big.js، decimal.js یا BigInt برای محاسبات.



20. رویکرد شما برای پلی‌فیل کردن یا شیم کردن ویژگی‌های مدرن جاوااسکریپت برای مرورگرهای قدیمی در یک برنامه React چیست؟

استفاده از Babel + core-js برای تراپیلیشن/پلی‌فیل‌ها.
استفاده از پیکربندی browserslist برای هدف‌گذاری مرورگرهای پشتیبانی‌شده.
برای ویژگی‌های بحرانی (مثل fetch، Promise)، از پلی‌فیل‌های شرطی یا واردات دینامیک استفاده کنید.



