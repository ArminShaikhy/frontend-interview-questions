### 1. چگونه رندر سمت سرور (SSR) را در یک برنامه React پیاده‌سازی می‌کنید؟

**رویکرد**: استفاده از فریم‌ورکی مانند **Next.js** که تنظیمات SSR را ساده‌سازی می‌کند.

**مفهوم**:

- SSR کامپوننت‌های React را به HTML در سرور رندر می‌کند.
- این کار باعث بهبود **عملکرد بارگذاری اولیه**، **سئو** و **زمان تعاملی شدن** می‌شود.

**مثال Next.js**:

```tsx
// pages/index.tsx
export default function Home({ user }) {
  return <div>سلام، {user.name}</div>;
}

export async function getServerSideProps() {
  const res = await fetch("https://api.example.com/user");
  const user = await res.json();

  return { props: { user } };
}

SSR سفارشی (با استفاده از ReactDOMServer):
const html = ReactDOMServer.renderToString(<App />);

چه زمانی استفاده شود: صفحات عمومی که نیاز به سئو یا نمایش سریع اولیه دارند (مثل صفحات فرود، تجارت الکترونیک).


2. تفاوت بین کامپوننت‌های کنترل‌شده و کنترل‌نشده در React چیست؟ چه زمانی از هر کدام استفاده می‌کنید؟
کنترل‌شده: حالت فرم توسط React با استفاده از useState مدیریت می‌شود.
const [value, setValue] = useState("");
<input value={value} onChange={(e) => setValue(e.target.value)} />;

کنترل‌نشده: حالت فرم توسط DOM با استفاده از ref مدیریت می‌شود.
const inputRef = useRef();
<input ref={inputRef} />;

چه زمانی استفاده شود:

کنترل‌شده: برای اعتبارسنجی پویا، فیلدهای شرطی یا منطق پیچیده فرم.
کنترل‌نشده: برای فرم‌های ساده، ورودی‌های کنترل‌نشده (مثل آپلود فایل) یا سناریوهای حساس به عملکرد.



3. چگونه خطاهای مرزی (Error Boundaries) را در React مدیریت می‌کنید؟ آیا می‌توانید یک کامپوننت ساده خطای مرزی بنویسید؟
مفهوم:
خطاهای مرزی، خطاهای رندرینگ، چرخه حیات یا سازنده را در کامپوننت‌های فرزند می‌گیرند — نه در مدیریت‌کننده‌های رویداد یا کدهای غیرهمزمان.
مثال:
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
   827    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // ثبت خطا در سرویس مانیتورینگ
    console.error(error, info);
  }

  render() {
    return this.state.hasError ? (
      <h1>مشکلی پیش آمده است.</h1>
    ) : (
      this.props.children
    );
  }
}

// استفاده
<ErrorBoundary>
  <MyComponent />
</ErrorBoundary>;

چه زمانی استفاده شود: اطراف کامپوننت‌های اصلی ویژگی، مسیرها یا واردسازی‌های پویا.


4. چگونه یک برنامه React در مقیاس بزرگ با صدها کامپوننت را برای مقیاس‌پذیری و قابلیت نگهداری معماری می‌کنید؟
روش‌های کلیدی:

ساختار پوشه‌ای مدولار بر اساس حوزه یا ویژگی:/features/user
/features/dashboard
/shared/components


کامپوننت‌های اتمی و الگوهای UI قابل استفاده مجدد (مثل دکمه‌ها، ورودی‌ها).
ایمنی نوع با TypeScript.
مدیریت حالت به‌صورت مناسب: حالت محلی → context → سراسری (مثل Redux/Zustand).
تقسیم کد با استفاده از React.lazy یا واردسازی پویای Next.js.
استانداردهای لینتینگ/فرمت‌بندی/تست با ابزارها (ESLint، Prettier، Jest).
مستندات و Storybook برای کشف کامپوننت و هم‌راستایی با سیستم طراحی.



5. الگوی واگذاری رویداد چیست و React چگونه از آن در سیستم رویداد مصنوعی خود استفاده می‌کند؟
واگذاری رویداد: یک مدیریت‌کننده واحد (مثلاً روی document) به رویدادهای عناصر فرزند با استفاده از بالارفتن رویداد گوش می‌دهد.
رویدادهای مصنوعی React:

React یک گوش‌دهنده رویداد سراسری برای هر نوع رویداد به کانتینر DOM ریشه متصل می‌کند (نه به هر عنصر).
رویدادها در یک SyntheticEvent پیچیده شده‌اند تا رفتار یکسانی در مرورگرهای مختلف داشته باشند.
React رویدادها را از طریق درخت DOM مجازی به جای DOM واقعی بالا می‌برد.

مثال:
function App() {
  return <button onClick={() => console.log("کلیک شد")}>کلیک کنید</button>;
}

در پشت صحنه، این onClick از طریق یک گوش‌دهنده سراسری در ریشه مدیریت می‌شود که باعث بهبود عملکرد و بهره‌وری حافظه می‌شود.```
