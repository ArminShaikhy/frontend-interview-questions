### 1. چگونه مدل شیء سند HTML (DOM) و رابطه آن با DOM مجازی React را مفهوم‌سازی می‌کنید؟

**DOM** نمای درختی زنده مرورگر از سند HTML است. دستکاری مستقیم آن به دلیل reflowها/repaintها پرهزینه است.

React **DOM مجازی (VDOM)** را به‌عنوان یک نمایش سبک در حافظه از DOM معرفی می‌کند. در زمان تغییر وضعیت:

- React **تفاوت** بین درخت‌های VDOM قبلی و بعدی را محاسبه می‌کند.
- عملیات‌های واقعی DOM را با استفاده از تطبیق **دسته‌بندی و به حداقل می‌رساند**.

```jsx
useState باعث رندر مجدد می‌شود → تفاوت VDOM → به‌روزرسانی‌های حداقل DOM
```

این مدل عملکرد را بهبود می‌بخشد و رابط‌های کاربری اعلانی را ممکن می‌سازد.

<br />

### 2. مدل ذهنی شما برای ساختاردهی HTML معنایی در یک چارچوب مبتنی بر کامپوننت مثل React چیست؟

معناشناسی باید ساختار را هدایت کند، حتی در داخل کامپوننت‌ها. من **نقش‌ها و نیت‌ها** را به تگ‌های مناسب (`<nav>`، `<main>`، `<section>`، `<article>`) نگاشت می‌کنم.

مثال:

```jsx
function BlogPost({ title, content }) {
  return (
    <article>
      <h2>{title}</h2>
      <section>{content}</section>
    </article>
  );
}
```

از سوپ div اجتناب می‌کنم و کامپوننت‌ها را به‌عنوان بسته‌بندی‌های معنایی در نظر می‌گیرم و تا حد ممکن از تگ‌های HTML5 استفاده می‌کنم. این کار دسترسی‌پذیری و سئو را بهبود می‌بخشد.

<br />

### 3. درباره تعامل بین ویژگی‌های HTML (مثل `data-*`، `aria-*`) و پراپ‌های React چگونه فکر می‌کنید؟

React ویژگی‌های استاندارد HTML و ویژگی‌های خاص (`aria-*`، `data-*`) را به‌عنوان **پراپ‌هایی که به گره DOM منتقل می‌شوند** در نظر می‌گیرد.

```jsx
<button aria-label="Close" data-testid="close-btn">
  X
</button>
```

- `data-*`: برای تست، تحلیل یا هوک‌های رفتاری.
- `aria-*`: برای دسترسی‌پذیری (پشتیبانی از صفحه‌خوان).
- هر دو در JSX **شهروندان درجه یک** هستند و باید با دقت مدیریت شوند.

<br />

### 4. چگونه یک ساختار HTML را برای پشتیبانی از یک رابط کاربری پیچیده و تودرتو (مثل منوی ناوبری چندسطحی) طراحی می‌کنید در حالی که قابل نگهداری باشد؟

رویکرد:

- استفاده از تگ‌های معنایی: `<nav>`، `<ul>`، `<li>` و نقش‌های ARIA در صورت نیاز.
- رندر بازگشتی داده‌های تودرتو.
- نگه داشتن کامپوننت‌ها به‌صورت اتمی.

```jsx
function NavItem({ label, children }) {
  return (
    <li>
      {label}
      {children && <ul>{children.map(...)}</ul>}
    </li>
  );
}
```

نگرانی‌ها (مثل ارائه در مقابل منطق) را جدا می‌کنم و ناوبری کیبورد و دسترسی‌پذیری را تضمین می‌کنم.

<br />

### 5. رویکرد شما برای مدل‌سازی فرم‌های HTML در یک برنامه React، به‌ویژه برای اعتبارسنجی و ارسال چیست؟

من از **کامپوننت‌های کنترل‌شده** برای وضعیت قابل پیش‌بینی استفاده می‌کنم:

```jsx
const [email, setEmail] = useState("");
<input value={email} onChange={(e) => setEmail(e.target.value)} />;
```

برای اعتبارسنجی:

- استفاده از **Yup/Zod** + **React Hook Form** یا منطق سفارشی.
- اعتبارسنجی درون‌خطی در زمان blur/change.
- جلوگیری از پیش‌فرض در ارسال، مدیریت اقدامات غیرهمزمان به‌صورت امن.

```jsx
<form onSubmit={handleSubmit(onSubmit)} />
```

<br />

### 6. درباره تأثیر تجزیه و رندر HTML بر عملکرد بارگذاری صفحه چگونه استدلال می‌کنید؟

**مسیر رندر بحرانی** تحت تأثیر قرار می‌گیرد:

- **حجم HTML**: DOM بزرگ‌تر = تجزیه و رندر کندتر.
- **منابع مسدودکننده**: اسکریپت‌های هم‌زمان تجزیه DOM را به تأخیر می‌اندازند.
- **عمق DOM**: درخت‌های عمیق = پیچیدگی بیشتر در layout/reflow.

من با موارد زیر بهینه‌سازی می‌کنم:

- کاهش بار HTML اولیه (مثل بارگذاری تنبل رابط کاربری غیربحرانی).
- اولویت‌بندی ترتیب محتوا (بالای صفحه).
- استفاده از SSR/Streaming برای بهبود زمان تا اولین بایت.

<br />

### 7. مدل ذهنی شما برای مدیریت رویدادهای HTML در یک برنامه React در مقایسه با جاوااسکریپت خام چیست؟

در React:

- رویدادها **مصنوعی** هستند: برای ثبات بین‌مرورگری بسته‌بندی شده‌اند.
- مثل رویدادهای بومی حباب می‌کنند اما با سیستم نمایندگی React (در ریشه).

```jsx
<button onClick={handleClick}>Click me</button>
```

مزایا:

- رفتار ثابت.
- مدیریت آسان‌تر حافظه.
- به‌روزرسانی‌های دسته‌ای.

در جاوااسکریپت خام:

- شنونده‌ها را مستقیماً به عناصر اضافه می‌کنید.
- نیاز به تمیزکاری دستی است.

React چرخه عمر و عملکرد را ساده می‌کند.

<br />

### 8. چگونه ساختارهای HTML را برای پشتیبانی از بهبود پیش‌رونده در یک برنامه مبتنی بر React طراحی می‌کنید؟

من HTML را برای کار **بدون جاوااسکریپت ابتدا** می‌سازم، سپس با React بهبود می‌دهم.

مثال:

- رندر HTML SSR با لینک‌ها و دکمه‌های کاربردی.
- هیدراتاسیون در کلاینت برای تعامل غنی‌تر (مثل مدال‌ها، جستجو).

استفاده از:

- HTML معنایی
- پیام‌رسانی فال‌بک `<noscript>`
- رویکرد دسترسی‌پذیری‌محور (ناوبری کیبورد، فوکوس قابل مشاهده)

```html
<button type="submit">Search</button>
```

بهبود شامل افزودن فیلترها، انیمیشن‌ها و غیره پس از هیدراتاسیون است.

<br />

### 9. درباره نقش HTML در یک برنامه React رندرشده سمت سرور (SSR) چگونه فکر می‌کنید؟

HTML در SSR **رندر اولیه** است که به مرورگر تحویل داده می‌شود:

- **زمان تا اولین نقاشی (TTFP)** و سئو را بهبود می‌بخشد.
- React HTML را به یک اپلیکیشن زنده هیدراته می‌کند.

مدلم:

- نگه داشتن نشانه‌گذاری معنایی و حداقل برای SSR.
- استفاده از تگ‌های `<head>` برای متا، عنوان، پیش‌بارگذاری (از طریق `react-helmet` یا `@vitejs/plugin-react`).
- اجتناب از رندر غیرقطعی (مثل `window`، `localStorage` در سرور).

<br />

### 10. مدل ذهنی شما برای مدیریت متادیتای HTML (مثل `<meta>`، `<link>`) در یک برنامه تک‌صفحه‌ای (SPA) چیست؟

من متادیتا را به‌عنوان بخشی از **زمینه مسیر پویا** در نظر می‌گیرم. برای SPAها:

- استفاده از `react-helmet` یا `@tanstack/router` برای تنظیم اعلانی `<title>`، `<meta>` و غیره.
- در زمان تغییر مسیر، سر را برای سئو + اشتراک‌گذاری اجتماعی به‌روزرسانی می‌کنم.

```jsx
<Helmet>
  <title>Product Page</title>
  <meta name="description" content="Details about product" />
</Helmet>
```

برای PWAها، همچنین `<link rel="manifest">`، آیکون‌ها و نکات پیش‌بارگذاری را مدیریت می‌کنم.