### 1. چگونه پتانسیل WebAssembly را در یک برنامه React ارزیابی می‌کنید؟

**پاسخ:**

من WebAssembly (Wasm) را برای وظایف حساس به عملکرد، مانند پردازش ویدئو، محاسبات سنگین ریاضی یا دستکاری تصویر در نظر می‌گیرم. ارزیابی می‌کنم:

- آیا زبان‌های بومی (مثل Rust، C++) به‌طور قابل‌توجهی از JS بهتر عمل می‌کنند
- آیا گلوگاه‌های JS موجود پیچیدگی را توجیه می‌کنند

مثال:

استفاده از Wasm کامپایل‌شده از Rust برای فشرده‌سازی تصاویر در سمت کلاینت:

```jsx
import initWasm from "./wasm/image_compression";
useEffect(() => {
  initWasm().then(() => compressImage(file));
}, []);
```

ادغام از طریق ماژول‌های غیرهمزمان، به‌ویژه در Web Workers، بدون مشکل است.

<br />

### 2. نظر شما درباره ظهور کامپوننت‌های سرور در React (مثل کامپوننت‌های سرور Next.js) چیست؟

**پاسخ:**

کامپوننت‌های سرور (RSC) امکان رندر جزئی سمت سرور را بدون ارسال JS غیرضروری به کلاینت فراهم می‌کنند. من آن‌ها را یک **پیروزی بزرگ در عملکرد** برای رابط‌های کاربری سنگین از نظر داده با تعامل کم می‌دانم.

مزایا:

- بسته JS صفر برای رابط کاربری رندرشده در سرور
- کاهش هزینه هیدراتاسیون
- دسترسی بهتر به داده‌های بک‌اند (مثل دسترسی مستقیم به پایگاه داده)

هشدار: پذیرش آن نیازمند بازنگری معماری و جداسازی واضح منطق کلاینت در مقابل سرور است.

<br />

### 3. چگونه یک پایگاه کد React را برای پذیرش ویژگی‌های نوظهور CSS (مثل Container Queries) آماده می‌کنید؟

**پاسخ:**

- استفاده از **CSS مبتنی بر ابزار یا محدود** (مثل Tailwind، CSS Modules) برای کاهش تعارض‌های جهانی
- انتزاع منطق طرح‌بندی به کامپوننت‌های متمرکز
- استفاده از **تشخیص ویژگی** و بهبود پیش‌رونده:

```css
@container (min-width: 400px) {
  .card {
    font-size: 1.2rem;
  }
}
```

- در صورت نیاز برای مرورگرهای قدیمی به پلی‌فیل‌ها (مثل `cqfill`) متوسل می‌شوم
- مدولار ماندن—رفاکتور کردن استایل‌ها هنگام ورود ویژگی‌های جدید آسان‌تر است

<br />

### 4. رویکرد شما برای ادغام ویژگی‌های مبتنی بر هوش مصنوعی (مثل چت‌بات‌ها، شخصی‌سازی) در یک برنامه React چیست؟

**پاسخ:**

- ویژگی‌های هوش مصنوعی را به‌عنوان **سرویس‌های مدولار** در نظر می‌گیرم، اغلب جدا از هسته رابط کاربری:
  - چت‌بات از طریق WebSocket → هوک `useEffect` + مدیر وضعیت
  - شخصی‌سازی از طریق پرچم‌های ویژگی یا رندر مبتنی بر استنباط

مثال:

```jsx
useEffect(() => {
  fetch("/api/recommendations?user=123")
    .then((res) => res.json())
    .then(setSuggestions);
}, []);
```

**تأخیر**، **فال‌بک‌ها** و **تجربه کاربری اخلاقی** (بازخورد واضح، بدون توهم) را در اولویت قرار می‌دهم.

<br />

### 5. چگونه تأثیر پیشنهادات جدید ECMAScript جاوااسکریپت را بر یک پروژه React ارزیابی می‌کنید؟

**پاسخ:**
من مراحل TC39 را دنبال کرده و ارزیابی می‌کنم:

- پیشنهادات مرحله 3+ برای آزمایش عملی
- پشتیبانی مرورگر و ابزارهای ساخت (مثل Vite/Babel)
- بهره‌وری توسعه‌دهنده در مقابل ریسک

مثال: **Records & Tuples** تغییرناپذیری ساختاری را به منطق reducer می‌آورند.

در پروژه‌های جانبی آزمایش می‌کنم و در صورت امیدبخش بودن، از طریق `babel-plugin-proposal-*` معرفی می‌کنم.

<br />

### 6. استراتژی شما برای آینده‌نگری یک برنامه React در برابر منسوخ شدن چارچوب چیست؟

**پاسخ:**

- محصورسازی منطق (مثل سرویس‌ها، هوک‌ها، وضعیت) از جزئیات چارچوب
- دنبال کردن **اولویت استانداردها** (مثل Web Components، Fetch بومی)
- استفاده از انتزاع‌ها برای روترها، فرم‌ها، وضعیت—آسان برای تعویض:

```jsx
// src/hooks/useUser.ts
export const useUser = () => useQuery("user", fetchUser);
```

- اجتناب از اتصال تنگاتنگ به APIهای ناپایدار یا داخلی‌های خصوصی

این کار مهاجرت (مثل به Next.js یا Astro) را با اصطکاک کمتر ممکن می‌کند.

<br />

### 7. چگونه از APIهای مدرن مرورگر (مثل Intersection Observer، WebGPU) در یک برنامه React بهره می‌برید؟

**پاسخ:**
من استفاده می‌کنم:

- `IntersectionObserver` برای بارگذاری تنبل یا اسکرول بی‌نهایت:

```jsx
useEffect(() => {
  const observer = new IntersectionObserver(callback);
  observer.observe(ref.current);
}, []);
```

- `WebGPU` (در صورت پشتیبانی) برای رندر پیشرفته یا بارهای کاری ML—مدولار شده در یک هوک `useCanvasRenderer`

همیشه در `useEffect` یا هوک‌های سفارشی با تشخیص ویژگی پیچیده می‌شوند:

```jsx
if ("gpu" in navigator) {
  /* WebGPU logic */
}
```

<br />

### 8. نظر شما درباره تکامل کتابخانه‌های مدیریت وضعیت فراتر از Redux و Zustand چیست؟

**پاسخ:**
روند به سمت ابزارهای **سبک**، **مقیاس‌پذیر** و **واکنشی** است:

- **Jotai/Recoil**: واکنش‌پذیری اتمی و محدود
- **React Query/TanStack Query**: مدیریت وضعیت سرور
- **سیگنال‌ها (Preact، Angular)** اشاره‌ای به مدل‌های آینده React دارند

من **انسجام با مدل ذهنی React** و **کد نمونه کم** را در اولویت قرار می‌دهم. Zustand به دلیل سادگی پیش‌فرض من است، مگر اینکه افکت‌های جهانی یا به‌روزرسانی‌های خوش‌بینانه نیاز به ابزارهای بیشتری داشته باشند.

<br />

### 9. چگونه در عین حفظ پایداری در یک برنامه React تولیدی، از روندهای فرانت‌اند جلوتر می‌مانید؟

**پاسخ:**

- دنبال کردن **RFCها**، تغییرات و اعضای تیم اصلی (Dan Abramov و غیره)
- جداسازی آزمایش‌ها در سندباکس‌ها/شاخه‌های ویژگی
- حفظ یک **رادار فناوری**: آزمایش → ارزیابی → پرورش → پذیرش
- استفاده از **پرچم‌های ویژگی** و **انتشارهای کناری** برای انتشار ایمن
- اطمینان از پوشش CI و نظارت برای محافظت از تولید در برابر پسرفت‌ها

<br />

### 10. چگونه تیمی را برای پذیرش مسئولانه فناوری‌های نوظهور در یک پایگاه کد React راهنمایی می‌کنید؟

**پاسخ:**

- با نمونه‌سازی فناوری جدید با موارد تجاری واقعی پیشگام می‌شوم
- اجرای **اسپایک‌های فناوری** و **گفت‌وگوهای داخلی** با مزایا/معایب
- مستندسازی الگوها (مثل نحوه استفاده از کامپوننت‌های سرور)
- برنامه‌نویسی جفتی برای ایجاد اعتماد
- تعیین **معیارهای پذیرش**: بلوغ، پشتیبانی اکوسیستم، تأثیر

من کنجکاوی را تشویق می‌کنم که با عمل‌گرایی متعادل شده باشد: فناوری باید مشکلات را حل کند، نه مشکلات جدید ایجاد کند.