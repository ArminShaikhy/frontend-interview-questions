### 1. چگونه با تیم‌های بک‌اند همکاری می‌کنید تا APIهایی طراحی شوند که نیازهای یک فرانت‌اند React را برآورده کنند؟

من با هم‌راستا کردن **موارد استفاده و نیازهای داده‌ای** از طریق قراردادهای API یا مشخصات OpenAPI شروع می‌کنم. از موارد زیر حمایت می‌کنم:

- **REST یا GraphQL** بسته به پیچیدگی
- ساختارهای منابع یکنواخت
- پشتیبانی از صفحه‌بندی، فیلتر کردن و مرتب‌سازی

ما از **Postman/Swagger** برای ماک‌های اولیه و **اسناد طراحی API مشترک** استفاده می‌کنیم. بر **تفکر فرانت‌اندمحور** تأکید دارم: کاهش جلب بیش‌ازحد داده و پشتیبانی از بلادرنگ یا بارگذاری تنبل در صورت نیاز.

<br />

### 2. رویکرد شما برای مدیریت نسخه‌بندی API در یک برنامه React وقتی بک‌اند تکامل می‌یابد چیست؟

**پاسخ:**

من **نسخه‌بندی مبتنی بر URL** (مثل `/v1/users`) را برای وضوح و قابلیت کش ترجیح می‌دهم. در React:

- کپسوله‌سازی منطق API در سرویس‌ها:

```jsx
// api/user.ts
export const fetchUser = () => axios.get("/v2/کاربر");


استفاده از پرچم‌های ویژگی یا سوئیچ‌های مبتنی بر محیط برای مهاجرت نرم
ردیابی انحراف نسخه با تست‌های یکپارچگی



3. چگونه یک فرانت‌اند React را برای مدیریت APIهای ناسازگار یا ضعیف مستند شده طراحی می‌کنید؟
پاسخ:
برای کاهش ریسک:

استفاده از TypeScript با اعتبارسنج‌های اجرایی مثل zod یا io-ts:

const UserSchema = z.object({ id: z.string(), name: z.string() });


انتزاع پاسخ‌های API از طریق آداپتورها برای نرمال‌سازی داده‌ها:

const mapUser = (data) => ({ id: data.user_id, name: data.full_name });


مستندسازی و علامت‌گذاری ناسازگاری‌ها برای بازسازی بک‌اند



4. استراتژی شما برای بهینه‌سازی بارهای API برای عملکرد یک برنامه React چیست؟
پاسخ:

درخواست فقط فیلدهای مورد نیاز (fields=name,email یا مجموعه‌های انتخاب GraphQL)
صفحه‌بندی لیست‌ها برای کاهش بار:

axios.get('/کاربران?page=2&limit=10');


فشرده‌سازی پاسخ‌ها (Gzip/Brotli) و کش در صورت امکان
استفاده از مرتب‌سازی/فیلتر کردن مبتنی بر سرور برای جلوگیری از سربار سمت کلاینت



5. چگونه APIهای بلادرنگ (مثل WebSockets، Server-Sent Events) را در یک برنامه React ادغام می‌کنید؟
پاسخ:

استفاده از WebSocket برای داده‌های دوطرفه:

useEffect(() => {
  const socket = new WebSocket("wss://example.com/socket");
  socket.onmessage = (event) => updateState(JSON.parse(event.data));
}, []);


استفاده از زمینه یا Zustand برای اشتراک به‌روزرسانی‌های حالت
برای SSE: استفاده از EventSource، اما در صورت نیاز به عقب‌گرد به نظرسنجی
پاک‌سازی سوکت‌ها در هنگام جداسازی برای جلوگیری از نشت حافظه



6. رویکرد شما برای ماک کردن APIها در طول توسعه React وقتی بک‌اند آماده نیست چیست؟
پاسخ:

استفاده از Mock Service Worker (MSW) برای رهگیری fetch/axios واقعی:

rest.get('/api/کاربر', (req, res, ctx) => res(ctx.json({ name: 'تست' })));


انعکاس قرارداد بک‌اند با استفاده از ماک‌های JSON یا Swagger
فعال‌سازی حالت ماک از طریق NODE_ENV یا پرچم توسعه
ماک در سطح شبکه برای تست یکپارچگی، نه منطق



7. چگونه APIهای محدود شده توسط نرخ را در یک برنامه React مدیریت می‌کنید بدون کاهش تجربه کاربری؟
پاسخ:

پیاده‌سازی بازگشت نمایی یا مدیریت سربرگ‌های Retry-After
صف‌بندی یا محدود کردن درخواست‌های با فرکانس بالا:

const debouncedSearch = debounce(fetchSuggestions, 300);


نمایش بازخورد رابط کاربری (مثل اسپینرها، دکمه‌های امتحان مجدد)
کش پاسخ‌های مکرر به‌صورت محلی در صورت امکان (مثل react-query، SWR)



8. فرآیند شما برای اشکال‌زدایی مشکلات یکپارچگی فرانت‌اند-بک‌اند در یک برنامه React چیست؟
پاسخ:

بررسی تب شبکه (کدهای وضعیت، سربرگ‌ها، بدنه)
استفاده از console.error یا مرزهای خطا برای دید
اعتبارسنجی انواع API با استفاده از اسکیماها
ثبت و مقایسه درخواست فرانت‌اند با انتظارات بک‌اند
استفاده از Postman یا curl برای ایزوله کردن مشکلات بک‌اند

همکاری نزدیک با مهندسان بک‌اند، ترجیحاً در جلسات اشکال‌زدایی بلادرنگ.


9. چگونه برای نیازهای فرانت‌اند (مثل صفحه‌بندی، فیلتر کردن) در بحث‌های طراحی API بک‌اند حمایت می‌کنید؟
پاسخ:

ارائه سناریوهای کاربرمحور که تأثیر را نشان می‌دهند (مثل بارگذاری کند، تجربه کاربری ضعیف)
پیشنهاد استانداردها مثل پارامترهای کوئری limit، offset، sort، filter
تأکید بر عملکرد موبایل و دانه‌بندی داده
استفاده از مشخصات API مشترک یا مثال‌ها برای پر کردن شکاف‌ها



10. چگونه یک تیم فرانت‌اند را برای همکاری مؤثر با مهندسان بک‌اند در یک پروژه React آموزش می‌دهید؟
پاسخ:

معرفی ذهنیت طراحی API اول (مثل OpenAPI، GraphQL schema-first)
تعریف قراردادهای واضح و استفاده از ابزارهایی مثل MSW برای توسعه
تشویق به بررسی‌های مشترک طراحی‌های API
ایجاد قراردادهای یکنواخت (مثل انتزاع سرویس، مدیریت خطا)
ترویج همکاری مبتنی بر همدلی با مشارکت هر دو طرف در دموها و بازنگری‌های یکدیگر



