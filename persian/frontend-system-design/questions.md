### 1. چگونه یک سیستم فرانت‌اند برای مدیریت یک پلتفرم تجارت الکترونیک پرترافیک با میلیون‌ها کاربر همزمان طراحی می‌کنید؟

**استراتژی‌های کلیدی**:

- **رندرینگ سمت سرور (SSR)** یا **تولید سایت استاتیک (SSG)** از طریق Next.js برای صفحات محصول/دسته‌بندی برای کاهش TTFB.
- **کش CDN** برای دارایی‌های استاتیک و پاسخ‌های SSR.
- استفاده از **تقسیم کد** و **بارگذاری تنبل** برای جزئیات محصول، نظرات و غیره.
- واگذاری رابط کاربری سنگین (مثل جستجو، فیلترها) به **رندرینگ سمت کلاینت** با APIهای ناهمزمان.

```jsx
const Product = React.lazy(() => import("./Product"));



2. رویکرد شما برای طراحی یک معماری فرانت‌اند که به‌روزرسانی‌های بلادرنگ را در چندین کلاینت پشتیبانی کند (مثل اپلیکیشن چت یا داشبورد زنده) چیست؟
رویکرد:

استفاده از WebSockets (مثل Socket.IO یا بومی) یا رویدادهای ارسالی سرور برای داده‌های بلادرنگ.
استفاده از مدیریت حالت با صف‌های رویداد برای محدود کردن به‌روزرسانی‌ها و اطمینان از یکنواختی رابط کاربری.

socket.on("پیام_جدید", (msg) => {
  dispatch(addMessage(msg));
});


پیاده‌سازی حضور، شاخص‌های تایپ و صف‌های پیام در کلاینت برای تاب‌آوری.



3. چگونه یک سیستم فرانت‌اند طراحی می‌کنید که به‌طور بی‌درز بین حالت‌های آنلاین و آفلاین جابه‌جا شود؟
تکنیک‌ها:

استفاده از Service Workers برای کش آفلاین (از طریق Workbox).
کش اقدامات کاربر در IndexedDB با استفاده از کتابخانه‌هایی مثل idb.
همگام‌سازی اقدامات در صف هنگام بازیابی شبکه (از طریق رویدادهای navigator.onLine).

window.addEventListener("آنلاین", syncQueuedRequests);


استفاده از به‌روزرسانی‌های رابط کاربری خوش‌بینانه با بازگشت در صورت شکست همگام‌سازی.



4. چگونه یک سیستم فرانت‌اند برای پشتیبانی از بین‌المللی‌سازی (i18n) و محلی‌سازی (L10n) برای مخاطبان جهانی طراحی می‌کنید؟
معماری:

انتزاع تمام رشته‌ها و قالب‌ها با استفاده از ابزارهایی مثل react-i18next یا vue-i18n.
استفاده از مسیریابی مبتنی بر زبان (/en/، /fr/) برای سئو.
بارگذاری دینامیک فایل‌های زبان برای جلوگیری از باندل‌های سنگین.

i18n.changeLanguage("fr"); // تغییر دینامیک زبان



5. استراتژی شما برای طراحی یک سیستم فرانت‌اند که با بک‌اند میکروسرویس‌ها ادغام شود چیست؟
استراتژی:

استفاده از دروازه API در بک‌اند برای انتزاع میکروسرویس‌ها از فرانت‌اند.
نرمال‌سازی و تبدیل پاسخ‌های میکروسرویس در یک لایه API سمت کلاینت.
مدیریت نسخه‌بندی، امتحان مجدد و پشتیبان‌ها به‌صورت متمرکز.



6. چگونه یک برنامه React را برای کاهش حجم باندل و بهینه‌سازی زمان بارگذاری اولیه برای یک اپلیکیشن بزرگ طراحی می‌کنید؟
تاکتیک‌ها:

تقسیم کد با React.lazy + Suspense.
استفاده از کتابخانه‌های پشتیبان‌کننده حذف کد غیرضروری.
بارگذاری JS غیربحرانی با async/defer.
استفاده از واردات دینامیک و پیش‌بارگذاری دارایی‌های بحرانی.
فشرده‌سازی با Brotli و ارائه از طریق CDN.



7. چگونه یک سیستم فرانت‌اند برای مدیریت صفحه‌بندی، اسکرول بی‌نهایت و مجموعه‌های داده بزرگ (مثل بیش از ۱۰۰,۰۰۰ رکورد) طراحی می‌کنید؟
بهترین روش‌ها:

استفاده از صفحه‌بندی مبتنی بر نشانگر از بک‌اند.
برای اسکرول بی‌نهایت، استفاده از IntersectionObserver و رندرینگ پنجره‌ای (مثل react-window، vue-virtual-scroll-list).

<FixedSizeList height={600} itemSize={35} itemCount={items.length}>
  {Row}
</FixedSizeList>


اجتناب از بارگذاری ۱۰۰,۰۰۰ رکورد در حافظه.



8. رویکرد شما برای طراحی یک استراتژی کش فرانت‌اند برای کاهش فراخوانی‌های API اضافی در یک برنامه React چیست؟
لایه‌های کش:

در حافظه با React Query / SWR (الگوی stale-while-revalidate).
کش پایدار از طریق IndexedDB یا localStorage برای داده‌های استاتیک.
استفاده از کلیدهای کش + ابطال در هنگام تغییر.



9. چگونه یک سیستم فرانت‌اند برای مدیریت افزایش ترافیک ناگهانی (مثل فروش‌های بلک فرایدی) بدون کاهش عملکرد طراحی می‌کنید؟

SSR با کش تمام‌صفحه CDN.
کاهش JS دینامیک — استفاده از معماری جزایر یا هیدراتاسیون جزئی.
نمایش حالت‌های بارگذاری زیبا، استفاده از رابط کاربری پشتیبان برای APIهای محدود شده توسط نرخ.
استفاده از پرچم‌های ویژگی برای غیرفعال کردن ویژگی‌های غیربحرانی در هنگام افزایش بار.



10. چگونه یک برنامه React را برای پشتیبانی از ویژگی‌های اپلیکیشن وب پیش‌رونده (PWA) مثل اعلان‌های فشاری و کش آفلاین طراحی می‌کنید؟
معماری:

استفاده از create-react-app یا افزونه PWA Next.js با Service Workers.
اعلان‌های فشاری از طریق Web Push API + سرور با VAPID.
کش مسیرها/دارایی‌ها از طریق استراتژی‌های Workbox (cacheFirst، networkFirst).

self.addEventListener('push', event => {
  self.registration.showNotification('پیشنهاد جدید!', {...});
});



11. چگونه یک سیستم مدیریت حالت برای یک برنامه React با کامپوننت‌های رابط کاربری پیچیده و وابسته به هم طراحی می‌کنید؟
رویکرد:

استفاده از Zustand، Redux Toolkit یا Pinia (Vue).
تقسیم حالت جهانی و محلی.
نرمال‌سازی داده‌های رابطه‌ای برای جلوگیری از تودرتو و وابستگی‌های حلقوی.
استفاده از انتخابگرهای مشتق‌شده و مموایزیشن برای عملکرد.



12. رویکرد شما برای طراحی یک سیستم فرانت‌اند که داده‌ها را به‌صورت دوطرفه و بلادرنگ با بک‌اند همگام‌سازی کند (مثل ویرایش مشارکتی) چیست؟
الگو:

استفاده از WebSockets + OT (تبدیل عملیاتی) یا CRDT (مثل Yjs).
تغییرات محلی به‌صورت خوش‌بینانه اعمال می‌شوند.
سرور تعارض‌ها را حل کرده و به‌روزرسانی‌ها را پخش می‌کند.

editor.onChange = (change) => socket.emit('doc:update', change);


حفظ نسخه‌بندی یا برچسب‌های زمانی برای جلوگیری از برخوردها.



13. چگونه یک سیستم فرانت‌اند برای مدیریت پایداری داده سمت کلاینت در رفرش‌های صفحه و جلسات طراحی می‌کنید؟
ابزارها:

استفاده از localStorage/sessionStorage برای داده‌های سبک (مثل تم، توکن‌ها).
استفاده از IndexedDB برای داده‌های پیچیده یا ساختاریافته (مثل سفارشات آفلاین).
همگام‌سازی به کش حافظه در هنگام بارگذاری.

localStorage.setItem('تم', 'تاریک');



14. چگونه یک سیستم فرانت‌اند برای مدیریت APIهای محدود شده توسط نرخ یا غیرقابل اعتماد بدون به خطر انداختن تجربه کاربری طراحی می‌کنید؟
استراتژی‌ها:

صف‌بندی درخواست‌ها و امتحان مجدد با بازگشت.
استفاده از الگوی قطع‌کننده مدار —غیرفعال کردن موقت ویژگی‌های مشکل‌دار.
پشتیبان‌های زیبا: داده‌های کش‌شده، رابط کاربری اسکلتی، حالت آفلاین.

axiosRetry(api, { retries: 3, retryDelay: exponentialDelay });



15. رویکرد شما برای طراحی یک سیستم فرانت‌اند که به‌روزرسانی‌های رابط کاربری خوش‌بینانه را پشتیبانی کند و در عین حال یکپارچگی داده با بک‌اند را تضمین کند چیست؟
جریان:

فوراً به‌روزرسانی حالت رابط کاربری (مثل لایک کردن پست).
ارسال درخواست ناهمزمان به بک‌اند.
در صورت خطا، بازگشت به حالت قبلی.

mutation.mutate(updateItem, {
  onMutate: () => updateCacheLocally(),
  onError: () => rollback(),
});

استفاده از react-query یا مدیر تغییر سفارشی برای ردیابی.


16. چگونه یک سیستم فرانت‌اند برای کار با بک‌اند GraphQL در مقابل بک‌اند RESTful طراحی می‌کنید؟
تفاوت‌های کلیدی:

GraphQL کوئری‌های انعطاف‌پذیر و دورهای کمتری ارائه می‌دهد.
REST نیاز به چندین نقطه پایانی دارد و اغلب جلب بیش‌ازحد داده.

استراتژی GraphQL:

استفاده از کلاینت GraphQL مثل Apollo Client یا urql.
تعریف کوئری‌ها به‌صورت هم‌مکان با کامپوننت‌ها.
بهره‌برداری از کش داخلی و قطعات برای مدولاریته.

const { data, loading } = useQuery(GET_PRODUCT, { variables: { id } });

استراتژی REST:

استفاده از یک لایه API متمرکز با Axios یا fetch.
نرمال‌سازی پاسخ‌ها با ابزارهایی مثل normalizr.
مدیریت دستی صفحه‌بندی/نسخه‌بندی.



17. چگونه یک سیستم فرانت‌اند برای ادغام با یک بک‌اند قدیمی با APIهای ناسازگار و زمان پاسخگویی کند طراحی می‌کنید؟
رویکرد:

معرفی یک لایه آداپتور سمت کلاینت برای نرمال‌سازی داده‌ها و انتزاع ناهنجاری‌ها.
استفاده از دروازه‌های API یا BFF (Backend-for-Frontend) در صورت امکان برای جداسازی فرانت‌اند از ناسازگاری‌های بک‌اند.
پیاده‌سازی تایم‌اوت‌ها، کش، رابط‌های اسکلتی بارگذاری و مدیریت خطای زیبا برای APIهای کند.

async function getNormalizedUser(id) {
  const raw = await legacyAPI.get(`/کاربر/${id}`);
  return { name: raw.username, age: raw.details?.age ?? null };
}



18. رویکرد شما برای طراحی یک سیستم فرانت‌اند که تست A/B و سوئیچ‌های ویژگی را در مقیاس پشتیبانی کند چیست؟
طراحی سیستم:

استفاده از یک ارائه‌دهنده پرچم ویژگی (مثل LaunchDarkly، Unleash یا خانگی).
پرچم‌ها باید قبل از رندرینگ حل شوند تا از چشمک زدن جلوگیری شود (SSR یا جلب زودهنگام).
برای تست‌های A/B، ادغام تحلیل‌ها برای ثبت رفتارهای متغیر.

{
  featureFlags.newCheckout ? <NewCheckout /> : <LegacyCheckout />;
}


پرچم‌ها باید تایپ‌شده، محدود و پس از آزمایش‌ها به‌صورت تمیز حذف شوند.



19. چگونه یک سیستم فرانت‌اند برای همکاری با تیم بک‌اند با استفاده از رویکرد قرارداد اول (مثل OpenAPI، اسکیماهای GraphQL) طراحی می‌کنید؟
بهترین روش‌ها:

استفاده از تایپ‌های خودکار تولیدشده از قراردادها (مثل graphql-codegen، openapi-typescript).
اعتبارسنجی درخواست‌ها/پاسخ‌ها از طریق اسکیماها (مثل Zod یا Yup).
اشتراک سرورهای ماک یا استفاده از MSW برای تست قرارداد.

// تایپ‌های تولیدشده از اسکیمای GraphQL
type GetUserQuery = {
  user: { id: string, name: string },
};


اعمال قوانین تکامل قرارداد (مثل فقط تغییرات افزودنی) برای جلوگیری از خراب شدن مصرف‌کنندگان.



20. چگونه یک سیستم فرانت‌اند برای پشتیبانی از چندین محیط استقرار (مثل توسعه، استیجینگ، تولید) با پیکربندی‌های مختلف طراحی می‌کنید؟
رویکرد:

خارجی‌سازی پیکربندی با استفاده از متغیرهای محیطی (مثل .env.*).
استفاده از process.env (React) یا import.meta.env (Vite) برای تزریق در زمان ساخت.

const apiBase = process.env.REACT_APP_API_URL;


اطمینان از تزریق مقادیر حساس فقط در زمان ساخت و عدم نشت به کلاینت.
خودکارسازی استقرارها با خطوط لوله CI/CD برای هر محیط.



21. چگونه یک سیستم فرانت‌اند برای مدیریت زیبا مسائل سازگاری مرورگر در طیف گسترده‌ای از دستگاه‌ها و نسخه‌ها طراحی می‌کنید؟
تکنیک‌ها:

استفاده از autoprefixer + پلی‌فیل‌های Babel (از طریق @babel/preset-env).
تشخیص ویژگی‌ها با Modernizr یا از طریق بررسی‌های اجرایی ('IntersectionObserver' in window).
ارائه باندل‌های مختلف با استفاده از بارگذاری تفاضلی یا polyfill.io.

if (!window.fetch) {
  loadPolyfill().then(initApp);
}


تست با ابزارهایی مثل BrowserStack یا Playwright.



22. رویکرد شما برای طراحی یک سیستم فرانت‌اند با استقرار بدون توقف چیست؟
روش‌ها:

استفاده از ساخت‌های غیرقابل تغییر با هش محتوا (مثل main.abc123.js) و استقرارهای اتمی.
اجتناب از تغییرات خراب‌کننده در APIها یا ذخیره‌سازی بین نسخه‌ها.
استفاده از پرچم‌های ویژگی برای جداسازی استقرار از انتشار.

<script src="/static/js/main.[hash].js" defer></script>


استفاده محتاطانه از Service Workers (PWA) برای جلوگیری از کش‌های قدیمی (نسخه‌بندی صریح آن‌ها).



23. چگونه یک سیستم نظارت فرانت‌اند برای ردیابی عملکرد، خطاها و رفتار کاربر در تولید طراحی می‌کنید؟
ابزارها:

خطاها: Sentry، Rollbar برای استثناهای JS و ردپاها.
عملکرد: Web Vitals، معیارهای سفارشی از طریق Google Analytics، Datadog RUM یا New Relic.
رفتار: FullStory، PostHog یا ردیابی رویدادهای سفارشی.

reportWebVitals((metric) => sendToAnalytics(metric));


گروه‌بندی و هشدار درباره خطاها بر اساس کامپوننت/نسخه، و استفاده از نقشه‌های منبع در تولید.



24. چگونه یک سیستم فرانت‌اند برای پشتیبانی از نگهداری بلندمدت توسط تیمی با سطوح مهارت مختلف طراحی می‌کنید؟
استراتژی‌ها:

اعمال استانداردهای کدنویسی با ESLint، Prettier و TypeScript سخت‌گیرانه.
استفاده از سیستم‌های طراحی و کتابخانه‌های کامپوننت (مثل Storybook).
ارائه ساختار پوشه‌ای واضح، اسناد README و هوک‌های کامیت لینت‌شده.

"scripts": {
  "lint": "eslint src --ext .js,.ts,.tsx",
  "typecheck": "tsc --noEmit"
}


تأکید بر بررسی‌های کد، مربی‌گری و نوشتن تست‌ها (واحدی + E2E).



25. رویکرد شما برای طراحی یک سیستم فرانت‌اند که از خرابی‌های فاجعه‌بار (مثل حالت خراب‌شده، قطعی شبکه) بازیابی کند چیست؟
استراتژی دفاعی:

بسته‌بندی منطق حالتمند در مرزهای خطا برای ایزوله کردن خرابی‌ها.

<ErrorBoundary fallback={<Fallback />}>
  <Dashboard />
</ErrorBoundary>


ذخیره حالت بحرانی در ذخیره‌سازی مقاوم (مثل IndexedDB با اعتبارسنجی اسکیما).
صف‌بندی اقدامات آفلاین و امتحان مجدد با بازگشت نمایی.
پشتیبان‌گیری به رابط کاربری کش‌شده در صورت امکان (Service Worker، تصویر localStorage).



