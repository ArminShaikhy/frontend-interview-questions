### 1. از چه تکنیک‌هایی می‌توانید برای بهینه‌سازی عملکرد یک برنامه React استفاده کنید؟

- **تقسیم کد** با `React.lazy` و واردات دینامیک.
- **مموایزیشن** با استفاده از `React.memo`، `useMemo` و `useCallback` برای جلوگیری از محاسبات و رندرهای غیرضروری.
- **مجازی‌سازی** با `react-window` یا `react-virtualized` برای لیست‌های بزرگ.
- **محدود کردن/تاخیر دادن** به‌روزرسانی‌های پرهزینه (مثل ورودی‌های جستجو).
- **رندرینگ انتخابی** با استفاده از `shouldComponentUpdate`، `React.PureComponent` یا وابستگی‌های مناسب `useEffect`.
- **بهینه‌سازی تصاویر**، بارگذاری تنبل دارایی‌ها و ارائه باندل‌های فشرده.

<br />

### 2. هدف از `React.memo` را توضیح دهید و چه زمانی از آن استفاده می‌کنید.

`React.memo` یک HOC است که **جلوگیری از رندرهای غیرضروری** یک کامپوننت را در صورتی که پراپ‌های آن تغییر نکرده باشند، انجام می‌دهد.

**مورد استفاده:** کامپوننت‌های تابعی که **خالص** هستند و پراپ‌های یکسانی را به‌کرات دریافت می‌کنند.

به‌ویژه در **رندرینگ لیست‌ها** یا کامپوننت‌های تودرتو که والد آن‌ها به‌طور مکرر رندر می‌شود، مفید است.

<br />

### 3. هوک‌های `useCallback` و `useMemo` چگونه کار می‌کنند و چگونه به عملکرد کمک می‌کنند؟

- `useCallback(fn, deps)` یک **نسخه مموایز شده از یک کال‌بک** را برمی‌گرداند.
- `useMemo(fn, deps)` یک **نتیجه مموایز شده از یک محاسبه** را برمی‌گرداند.

**چرا مهم است:** جلوگیری از **بازسازی غیرضروری** توابع یا مقادیر، که به جلوگیری از رندرها یا محاسبات مجدد کمک می‌کند، به‌ویژه هنگام انتقال پراپ‌ها به کامپوننت‌های فرزند یا وابستگی‌ها به `useEffect`.

<br />

### 4. تقسیم کد در React چیست و چگونه می‌توانید آن را با استفاده از بارگذاری تنبل پیاده‌سازی کنید؟

تقسیم کد برنامه شما را به **تکه‌های کوچک‌تر** تقسیم می‌کند که **بر اساس تقاضا** بارگذاری می‌شوند، و زمان بارگذاری اولیه را بهبود می‌بخشند.

```jsx
const Profile = React.lazy(() => import('./Profile'));

این کد Profile را فقط در صورت نیاز بارگذاری می‌کند. از React.lazy با Suspense برای تقسیم کد مبتنی بر مسیر یا سطح کامپوننت استفاده کنید.


5. چگونه یک مشکل عملکردی ناشی از رندرینگ بیش‌ازحد در یک برنامه React را اشکال‌زدایی و رفع می‌کنید؟
مراحل:

فعال‌سازی React DevTools → برجسته کردن رندرها.
استفاده از تب Profiler برای یافتن کامپوننت‌های به‌روزرسانی‌شده مکرر.
بررسی وابستگی‌های پراپ‌ها/حالت و مموایز کردن کامپوننت‌ها (React.memo) یا کال‌بک‌ها (useCallback).
اطمینان از اینکه useEffect و مصرف‌کنندگان زمینه باعث به‌روزرسانی‌های غیرضروری نمی‌شوند.
اعمال منطق shouldComponentUpdate یا useMemo برای جلوگیری از رندرها.



6. چگونه Core Web Vitals (LCP، FID، CLS) را در یک برنامه React.js اندازه‌گیری و بهبود می‌دهید؟

اندازه‌گیری با استفاده از کتابخانه Web Vitals، Lighthouse یا ابزارهایی مثل PageSpeed Insights.
LCP: بهینه‌سازی تصاویر، رندرینگ سمت سرور محتوای بالای صفحه.
FID: کاهش زمان مسدود شدن جاوااسکریپت، به تعویق انداختن JS غیربحرانی.
CLS: استفاده از ابعاد مناسب برای تصاویر/ویدئوها، جلوگیری از کامپوننت‌های تغییر دهنده چیدمان.



7. زمانی را توصیف کنید که یک گلوگاه عملکردی را در یک برنامه فرانت‌اند شناسایی و رفع کردید.
در یک داشبورد داده‌محور، نمودارها با هر تغییر حالت به دلیل پراپ‌های جدید که هر بار منتقل می‌شدند، رندر مجدد می‌کردند. من:

کامپوننت‌های نمودار را در React.memo پیچیدم.
از useMemo برای محاسبه پراپ‌ها استفاده کردم.
به‌روزرسانی‌های حالت را با استفاده از useTransition دسته‌بندی کردم.

این کار زمان رندر را از ~۸۰۰ میلی‌ثانیه به ~۱۰۰ میلی‌ثانیه کاهش داد و تأخیر رابط کاربری را حذف کرد.


8. چگونه یک برنامه React که به دلیل حجم باندل بزرگ از زمان بارگذاری اولیه کند رنج می‌برد را بهینه می‌کنید؟

تقسیم کد بر اساس مسیر و کامپوننت (React.lazy).
حذف کد غیرضروری از کتابخانه‌های استفاده‌نشده (مثل وارد کردن فقط توابع مورد نیاز از lodash).
استفاده از واردات دینامیک برای کامپوننت‌های سنگین (مثل نمودارها، نقشه‌ها).
به تعویق انداختن اسکریپت‌های شخص ثالث مثل تحلیل‌ها.
استفاده از تحلیل‌گر webpack برای بررسی حجم باندل و حذف اضافه‌ها.



9. چگونه یک برنامه React را برای شناسایی رندرهای غیرضروری یا نشت‌های حافظه پروفایل می‌کنید؟

استفاده از پروفایلر React DevTools:
ضبط تعاملات.
بررسی “چرا این رندر شد؟” از طریق بینش‌های React 18.


استفاده از Chrome DevTools → تب Memory:
بررسی درخت‌های DOM جدا شده و اشیاء نگه‌داری‌شده.


افزودن لاگ‌ها یا console.count داخل کامپوننت‌ها برای نظارت بر رندرها.



10. متوجه یک نشت حافظه در یک برنامه React می‌شوید. چگونه آن را شناسایی و رفع می‌کنید؟
شناسایی:

استفاده از Chrome DevTools → Memory → گرفتن اسنپ‌شات‌ها.
بررسی شنونده‌های رویداد، تایمرها یا بسته‌های نگه‌داری‌شده.
بررسی کامپوننت‌های جدا شده که هنوز در حافظه هستند.

رفع:

پاک‌سازی اثرات جانبی در useEffect:

useEffect(() => {
  const timer = setInterval(() => {}, 1000);
  return () => clearInterval(timer);
}, []);


جلوگیری از نگه‌داری حالت در تک‌رخ‌ها یا بسته‌های جهانی.
اطمینان از آزادسازی صحیح refs و گره‌های DOM.



