### 1. چگونه یک فروشگاه Redux را برای یک برنامه React بزرگ‌مقیاس با چندین دامنه (مثل کاربر، محصول، سبد خرید) ساختاردهی می‌کنید؟

من از **مدولاریزاسیون مبتنی بر ویژگی** پیروی می‌کنم و از **Redux Toolkit (RTK)** برای نگه داشتن اسلایس‌ها به‌صورت ایزوله و مقیاس‌پذیر استفاده می‌کنم.

```bash
/src
  /store
    store.ts
  /features
    /user
      userSlice.ts
      userSelectors.ts
    /product
      productSlice.ts
    /cart
      cartSlice.ts
```

هر اسلایس اقدامات، ردیوسر و سلکتورهای خود را مدیریت می‌کند. من آن‌ها را با استفاده از `combineReducers` ترکیب می‌کنم. این امکان موازی‌سازی تیم، کاهش جفت‌سازی و ترویج مرزهای دامنه واضح را فراهم می‌کند.

<br />

### 2. رویکرد شما برای مدیریت اقدامات غیرهمزمان در Redux (مثل Redux Thunk در مقابل Redux Saga) چیست؟

- من **Redux Thunk** را به دلیل سادگی و مستقیم بودن ترجیح می‌دهم.
- از **Redux Saga** زمانی استفاده می‌کنم که نیاز به **جریان‌های کاری پیچیده** دارم، مثل شرایط رقابتی، لغو یا وظایف طولانی‌مدت.

**مورد استفاده Saga:** تلاش مجدد با بازگشت نمایی یا هماهنگی فراخوانی‌های زنجیره‌ای.

<br />

### 3. چگونه عملکرد Redux را برای جلوگیری از رندرهای غیرضروری در یک برنامه React بهینه می‌کنید؟

- استفاده از **سلکتورهای مموایز شده** از طریق `reselect`.
- تقسیم وضعیت به اسلایس‌های دانه‌ریز برای کاهش جفت‌سازی.
- استفاده از `React.memo` و `useSelector` با بررسی‌های برابری سطحی.
- اجتناب از تودرتو کردن اشیاء بزرگ در وضعیت مگر اینکه نرمال‌سازی شده باشند.

<br />

### 4. پیچیده‌ترین ردیوسر Redux که نوشته‌اید چیست و چگونه اطمینان حاصل کردید که قابل پیش‌بینی و قابل تست باقی بماند؟

من یک ردیوسر برای مدیریت یک **ویزارد فرم چندمرحله‌ای** با منطق انشعاب و اعتبارسنجی غیرهمزمان نوشتم.

برای حفظ پیش‌بینی‌پذیری:

- منطق را به **توابع خالص کمکی** تقسیم کردم.
- از الگوی **ماشین حالت** برای تعریف انتقال‌های مجاز استفاده کردم.
- **تست‌های واحد** برای هر انتقال حالت با استفاده از Jest نوشتم.

<br />

### 5. چگونه یک برنامه Redux را زمانی که تغییرات وضعیت غیرمنتظره رخ می‌دهد اشکال‌زدایی می‌کنید؟

- استفاده از **Redux DevTools** برای بررسی اقدامات ارسال‌شده و سفر در زمان.
- لاگ کردن محموله‌های اقدام و تفاوت‌های وضعیت با میان‌افزار.
- ایزوله کردن از طریق **تست‌های واحد** روی منطق ردیوسر.
- بررسی دوباره سلکتورها برای جلوگیری از پروجکشن‌های داده‌ای قدیمی یا نادرست.

<br />

### 6. چگونه Redux را با TypeScript ادغام می‌کنید تا ایمنی نوع در اقدامات، ردیوسرها و سلکتورها تضمین شود؟

- استفاده از **Redux Toolkit** با `createSlice` و `createAsyncThunk` که به‌صورت خودکار تایپ‌ها را استنباط می‌کنند.
- تعریف **RootState تایپ‌شده** و `AppDispatch`.
- استفاده از `ReturnType<typeof store.getState>` برای استنباط تایپ جهانی.

<br />

### 7. رویکرد شما برای نرمال‌سازی وضعیت در Redux برای یک برنامه سنگین از نظر داده (مثل فید رسانه اجتماعی) چیست؟

- استفاده از `createEntityAdapter` از Redux Toolkit برای نرمال‌سازی داده‌ها.
- ذخیره موجودیت‌ها در قالب `byId` و استفاده از `ids` برای ترتیب.
- سلکتورها در زمان خواندن نرمال‌سازی را مدیریت می‌کنند.

<br />

### 8. چگونه میان‌افزار Redux را برای نگرانی‌های متقاطع مثل لاگ‌گیری، تحلیل یا احراز هویت مدیریت می‌کنید؟

- ایجاد **میان‌افزار سفارشی** که انواع اقدامات خاص را رهگیری می‌کند.
- استفاده از فیلدهای متا یا قراردادهای نام‌گذاری اقدام برای محدود کردن افکت‌ها.
- برای تحلیل، در صورت نیاز رویدادها را محدود و دسته‌بندی می‌کنم.

<br />

### 9. چگونه تداوم وضعیت Redux را در refresh صفحات یا راه‌اندازی مجدد اپلیکیشن مدیریت می‌کنید؟

- استفاده از `redux-persist` برای سریال‌سازی اسلایس‌هایی مثل احراز هویت یا سبد خرید به localStorage.
- فقط اسلایس‌های ضروری را در لیست سفید قرار می‌دهم.
- استفاده از نسخه‌بندی و مهاجرت برای مدیریت امن تغییرات طرح.

<br />

### 10. استراتژی شما برای مهاجرت یک برنامه Redux قدیمی به یک راه‌حل مدیریت وضعیت مدرن چیست؟

- معرفی **Redux Toolkit** به‌صورت تدریجی از طریق اسلایس‌ها.
- مهاجرت ردیوسرهای قدیمی به `createSlice`.
- جایگزینی سازندگان اقدام پرحرف با `createAsyncThunk`.
- اگر به Zustand/Recoil مهاجرت می‌کنم، **ویژگی به ویژگی** شروع می‌کنم در حالی که از طریق زمینه یا پراکسی‌ها پل می‌زنم.

<br />

### 11. چگونه یک فروشگاه Zustand را برای یک برنامه React با چندین ویژگی ساختاردهی می‌کنید؟

- استفاده از **فروشگاه‌های مدولار** برای هر دامنه، که در صورت نیاز به یک فروشگاه مرکزی ترکیب می‌شوند.
- نگه داشتن منطق در کنار ماژول‌های ویژگی برای انسجام.

برای وضعیت جهانی، چندین فروشگاه را صادر می‌کنم و به‌صورت اختیاری آن‌ها را با میان‌افزارهای Zustand ترکیب می‌کنم.

<br />

### 12. رویکرد شما برای مدیریت به‌روزرسانی‌های وضعیت غیرهمزمان در Zustand چیست؟

استفاده از توابع غیرهمزمان در داخل اقدامات. Zustand به‌صورت مستقیم از غیرهمزمان پشتیبانی می‌کند.

من از افکت‌های جانبی در کامپوننت‌ها اجتناب می‌کنم و اجازه می‌دهم فروشگاه منطق غیرهمزمان را مالک شود.

<br />

### 13. چگونه از سادگی Zustand برای بهبود بهره‌وری توسعه‌دهندگان در یک محیط تیمی استفاده می‌کنید؟

- بدون کد نمونه: مفاهیم کمتر، آماده‌سازی آسان‌تر.
- جای‌گیری مشترک وضعیت، اقدامات و منطق غیرهمزمان → تکرار سریع‌تر.
- ادغام آسان با کامپوننت‌ها با استفاده از `useStore`.
- نمونه‌سازی سریع بدون نیاز به اسکافولدینگ ردیوسرها/اقدامات.

نتیجه: بار شناختی کمتر، تحویل سریع‌تر ویژگی.

<br />

### 14. چگونه Zustand را با TypeScript ادغام می‌کنید تا وضعیت و اقدامات تایپ‌شده ایمن داشته باشید؟

- تعریف یک رابط برای وضعیت و اقدامات.
- استفاده از رابط در تعریف فروشگاه.

<br />

### 15. استراتژی شما برای تداوم وضعیت Zustand در جلسات یا تب‌ها چیست؟

- استفاده از تابع `persist` از `zustand/middleware` با localStorage یا sessionStorage.
- برای همگام‌سازی بین تب‌ها، استفاده از `zustand/middleware/subscribeWithSelector` + رویدادهای `storage`.

<br />

### 16. چگونه بین Redux و Zustand برای یک پروژه جدید React تصمیم می‌گیرید؟

| معیار                                     | استفاده از Redux | استفاده از Zustand |
| ----------------------------------------- | ---------------- | ------------------ |
| تیم بزرگ / الگوهای سخت‌گیرانه           | ✅               | ❌                 |
| ابزارهای توسعه جهانی، میان‌افزار        | ✅               | ✅ (با تنظیم)      |
| تنظیم حداقل / تکرار سریع                 | ❌               | ✅                 |
| جریان‌های کاری پیچیده (مثل ساگا)        | ✅               | ❌                 |
| وضعیت کامپوننت محلی یا وضعیت رابط کاربری گذرا | ❌               | ✅                 |

من Redux را زمانی انتخاب می‌کنم که نیاز به ساختار دارم یا تیم با آن آشناست. Zustand برای اپلیکیشن‌های کوچک‌تر، نمونه‌سازی یا زمانی که Redux بیش از حد به نظر می‌رسد.

<br />

### 17. تفاوت‌های فلسفی بین وضعیت متمرکز و تغییرناپذیر Redux و وضعیت منعطف و تغییرپذیر Zustand چیست؟

- **Redux**: بر **پیش‌بینی‌پذیری** از طریق تغییرناپذیری و ردیوسرهای خالص تأکید دارد. مناسب برای اپلیکیشن‌های بزرگ و مقیاس‌پذیر با الگوهای دقیق.
- **Zustand**: **سادگی و تغییر مستقیم** را در بر می‌گیرد، عمل‌گرایی و ارگونومی توسعه‌دهنده را در اولویت قرار می‌دهد.

Redux به رسمی‌سازی و ابزارسازی تمایل دارد؛ Zustand به سرعت و آزادی.

<br />

### 18. چگونه یک سیستم مدیریت وضعیت را طراحی می‌کنید که از یک نمونه اولیه کوچک به یک اپلیکیشن تولیدی با Redux یا Zustand مقیاس‌پذیر باشد؟

- با Zustand برای سرعت و سادگی شروع کنید.
- وضعیت و اقدامات را برای قابلیت ترکیب‌پذیری انتزاع کنید.
- با افزایش پیچیدگی، سازمان‌دهی مدولار و میان‌افزار را بپذیرید.
- اگر به‌طور قابل‌توجهی مقیاس‌پذیر شد (مشارکت‌کنندگان زیاد، غیرهمزمان پیچیده)، مهاجرت تدریجی به Redux Toolkit یا استفاده از میان‌افزارهای سفارشی Zustand برای اعمال نظم را در نظر بگیرید.

<br />

### 19. رویکرد شما برای تست منطق مدیریت وضعیت در Redux در مقابل Zustand چیست؟

**Redux:**

- تست واحد ردیوسرهای خالص و thunkهای غیرهمزمان با مدل‌ها.
- گرفتن اسنپ‌شات از انتقال‌های وضعیت پیچیده.
- استفاده از `redux-mock-store` برای تست‌های ادغام.

**Zustand:**

- تست مستقیم متدهای فروشگاه.

هر دو به‌راحتی قابل تست هستند، اما سادگی Zustand امکان تکرار سریع بدون سربار تست را فراهم می‌کند.

<br />

### 20. چگونه یک تیم را در انتخاب و پیاده‌سازی کتابخانه‌های مدیریت وضعیت مثل Redux یا Zustand آموزش می‌دهید؟

- با یک **ماتریس تصمیم‌گیری سبک** شروع کنید: آشنایی تیم، پیچیدگی اپلیکیشن، نیازهای ابزارسازی.
- برگزاری **گفت‌وگوهای فنی یا جلسات ناهار و یادگیری**: پوشش معاوضه‌ها و بهترین روش‌ها.
- برنامه‌نویسی جفتی و بررسی‌های کد.
- ارائه قالب‌های اولیه (Redux Toolkit یا بویلرپلیت‌های Zustand).
- تشویق به **RFCها** برای الگوهای جدید برای اطمینان از پذیرش.

تیم را توانمند کنید تا **انتخاب‌های آگاهانه** داشته باشند، نه اینکه صرفاً از روندها پیروی کنند.