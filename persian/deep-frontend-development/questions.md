### 1. چگونه یک معماری فرانت‌اند طراحی می‌کنید که بتواند برای میلیون‌ها کاربر مقیاس‌پذیر باشد و در عین حال عملکرد و بهره‌وری توسعه‌دهندگان را حفظ کند؟

**رویکرد:**

- **عملکرد**: استفاده از **تقسیم کد** (`React.lazy`)، **کش CDN**، **حذف کد غیرضروری** و **بهینه‌سازی مسیر رندر بحرانی**.
- **مقیاس‌پذیری**: پذیرش **معماری مدولار**، ساختار پوشه مبتنی بر ویژگی و **میکروفرانت‌اندها** برای تیم‌های بزرگ.
- **بهره‌وری توسعه‌دهندگان**: اعمال استانداردها از طریق **لینتینگ**، **Prettier**، **TypeScript** و **Storybook** برای کامپوننت‌های قابل استفاده مجدد.
- **ابزارها**: استفاده از **Vite** یا **ESBuild** برای ساخت سریع و **خطوط لوله CI/CD** برای اطمینان در مقیاس‌پذیری.

<br />

### 2. پیامدهای بلندمدت انتخاب معماری مبتنی بر کامپوننت (مثل React) نسبت به پارادایم‌های دیگر مانند MVC یا طراحی‌های فرانت‌اند یکپارچه چیست؟

- **مزایا**:
  - محصورسازی: منطق/رابط کاربری/وضعیت به‌صورت محلی مدیریت می‌شوند.
  - قابلیت استفاده مجدد: تشویق به DRY از طریق کتابخانه‌های کامپوننت.
  - مقیاس‌پذیری: امکان استفاده از میکروفرانت‌اند یا مرزهای تیمی مدولار.
- **معایب**:
  - می‌تواند منجر به **prop drilling** یا **کامپوننت‌های عمیقاً تودرتو** شود اگر با زمینه/هوک‌ها/کتابخانه‌های وضعیت مدیریت نشود.
  - خطر **انتزاع بیش‌ازحد** در صورت تعمیم زودهنگام کامپوننت‌ها.

<br />

### 3. چگونه بین نیاز به توسعه سریع ویژگی‌ها و ایجاد یک سیستم فرانت‌اند قوی و آینده‌نگرانه تعادل برقرار می‌کنید؟

- استفاده از **پرچم‌های ویژگی** برای تحویل تدریجی.
- تعریف و اعمال **قراردادهای کد** و **توکن‌های طراحی**.
- سرمایه‌گذاری زودهنگام در **کتابخانه‌های کامپوننت قابل استفاده مجدد**.
- تنظیم **حفاظ‌ها** (مثل CI، لینتینگ، تایپ‌ها) که سرعت را بدون ایجاد اصطکاک حفظ می‌کنند.

<br />

### 4. در یک معماری میکروفرانت‌اند، چگونه ثبات بین تیم‌ها را تضمین می‌کنید در حالی که استقلال در انتخاب فناوری را حفظ می‌کنید؟

- **سیستم طراحی**: توکن‌های طراحی و کامپوننت‌های رابط کاربری متمرکز (مثل Storybook یا Bit).
- **قراردادها**: استفاده از **تایپ‌های TypeScript مشترک** یا طرح‌های GraphQL.
- **ارتباط مستقل از فناوری**: استفاده از رویدادهای بومی مرورگر یا گذرگاه‌های پیام (مثل `postMessage`) برای ارتباط بین برنامه‌ها.

<br />

### 5. چگونه یک برنامه React با اتصال تنگاتنگ را به یک سیستم مدولار و با اتصال آزاد بازسازی می‌کنید بدون اختلال در توسعه جاری؟

- **الگوی خفه‌کننده**: جایگزینی تدریجی ماژول‌ها.
- استخراج منطق قابل استفاده مجدد به **هوک‌های سفارشی**.
- معرفی **مرزهای ویژگی** (مثل `features/Profile`) با استایل‌ها، کامپوننت‌ها و تست‌های محدود.
- استفاده از **لایه‌های رابط** یا آداپتورها برای جداسازی وابستگی‌ها.

<br />

### 6. چالش‌برانگیزترین مشکل عملکردی که در یک برنامه فرانت‌اند با آن مواجه شدید چیست و چگونه آن را حل کردید؟

**مشکل**: یک گرید داده React بیش از 10,000 ردیف را در هر تعامل رندر مجدد می‌کرد.

**راه‌حل**:

- رندر مجازی‌سازی‌شده با `react-window`.
- مموایزیشن با `React.memo` و `useMemo`.
- به‌روزرسانی‌های دسته‌ای وضعیت با `startTransition` (React 18+).

<br />

### 7. چگونه تصمیم می‌گیرید که یک بهینه‌سازی عملکردی (مثل مموایزیشن، بارگذاری تنبل) زودهنگام است یا ضروری؟

**زودهنگام**: وقتی بهینه‌سازی پیچیدگی را بدون تأثیر قابل اندازه‌گیری بر کاربر اضافه می‌کند.

**ضروری**:

- تأخیر قابل اندازه‌گیری (مثل TTI یا FID کند).
- گلوگاه‌ها در جریان‌های اصلی کاربر.
- ابتدا با ابزارهایی مثل Lighthouse، Web Vitals و React Profiler **بررسی** کنید.

<br />

### 8. درباره تعادل بین رندر سمت کلاینت، رندر سمت سرور و تولید سایت استاتیک در برنامه‌های React چگونه فکر می‌کنید؟

| استراتژی      | مزایا                       | معایب                        |
| ------------- | --------------------------- | ---------------------------- |
| CSR           | تعامل سریع                 | سئو ضعیف، نقاشی اولیه کندتر |
| SSR (Next.js) | سئو خوب، پویا              | هزینه سرور بالاتر            |
| SSG           | تحویل سریع‌ترین، سئو عالی  | برای داده‌های پویا مناسب نیست |

**قانون کلی**:

- **SSR** برای محتوای پویا که نیاز به سئو دارد.
- **SSG** برای صفحات بازاریابی.
- **CSR** برای برنامه‌های پشت احراز هویت.

<br />

### 9. نقش خط لوله رندر مرورگر در عملکرد فرانت‌اند چیست و چگونه از آن برای کاهش جابه‌جایی یا تحریک طرح‌بندی استفاده می‌کنید؟

**مراحل**: JS → استایل → طرح‌بندی → نقاشی → ترکیب

**برای بهینه‌سازی**:

- جلوگیری از تحریک طرح‌بندی: دسته‌بندی خواندن/نوشتن DOM.
- استفاده از `will-change`، `transform`، `opacity` برای انیمیشن‌های با عملکرد بالا.
- اجتناب از reflowهای اجباری (مثل خواندن `offsetHeight` پس از تغییر استایل).

<br />

### 10. چگونه یک برنامه React را برای دستگاه‌های کم‌قدرت یا شرایط شبکه ضعیف بهینه می‌کنید؟

- **حجم بسته**: تقسیم بر اساس مسیر با `React.lazy`.
- **تأخیر اسکریپت‌های غیربحرانی** و دارایی‌ها.
- **کاهش رندر مجدد** با `memo`، `useMemo`، `useCallback`.
- **لودرهای اسکلتی** به جای اسپینرها.
- پیش‌بارگذاری دارایی‌های موردنیاز احتمالی در زمان بیکاری با `requestIdleCallback`.

<br />

### 11. تفاوت‌های فلسفی بین مدیریت وضعیت واکنشی (مثل MobX) و جریان داده یک‌طرفه (مثل Redux) چیست؟

| ویژگی       | MobX                         | Redux                          |
| ----------- | ---------------------------- | ------------------------------ |
| پارادایم   | مشاهده‌پذیر (push)          | یک‌طرفه (pull)               |
| کد نمونه   | کم                          | بیشتر                         |
| اشکال‌زدایی | دشوار به دلیل به‌روزرسانی‌های مخفی | آسان‌تر به دلیل لاگ‌ها/سفر در زمان |

**Redux** برای پیش‌بینی‌پذیری بهتر است، **MobX** برای توسعه سریع و وضعیت محلی.

<br />

### 12. چگونه همگام‌سازی وضعیت را در چندین تب یا پنجره مرورگر در یک برنامه React مدیریت می‌کنید؟

- استفاده از `BroadcastChannel`، رویدادهای `localStorage` یا **Service Workers**.

```jsx
window.addEventListener("storage", (e) => {
  if (e.key === "auth") syncAuth(e.newValue);
});
```

برای برنامه‌های حیاتی: استفاده از کارگران مشترک یا همگام‌سازی مبتنی بر indexedDB.

<br />

### 13. پیچیده‌ترین مشکل مدیریت وضعیت که حل کرده‌اید چیست و چه چیزی آن را چالش‌برانگیز کرد؟

**سناریو**: همکاری بلادرنگ با پشتیبانی آفلاین.

**چالش‌ها**:

- حل تعارض (CRDTها)
- همگام‌سازی وضعیت محلی/آفلاین
- ادغام به‌روزرسانی‌های سرور بدون جابه‌جایی رابط کاربری

**راه‌حل**: استفاده از **صف مبتنی بر reducer سفارشی**، **تداوم indexedDB** و **رابط کاربری خوش‌بینانه** با بازگشت.

<br />

### 14. درباره مرز بین وضعیت فرانت‌اند و وضعیت بک‌اند در یک سیستم توزیع‌شده چگونه فکر می‌کنید؟

**فرانت‌اند**:

- وضعیت رابط کاربری/تجربه کاربری (مدال‌ها، فرم‌ها، انیمیشن‌ها)
- داده‌های کش‌شده سرور (از طریق SWR/Query)

**بک‌اند**:

- منبع حقیقت (احراز هویت، قوانین تجاری)

استفاده از **React Query** یا **Apollo** برای اتصال، با جداسازی واضح کش کلاینت از اقتدار سرور.

<br />

### 15. پیامدهای اتکای بیش‌ازحد به وضعیت جهانی در یک برنامه React چیست و چگونه از تبدیل شدن آن به یک «شیء خدا» جلوگیری می‌کنید؟

- ردیابی اشکالات دشوار است.
- اتصال تنگاتنگ → «شیء خدا».
- مانع استفاده مجدد از کامپوننت‌ها.

**راه‌حل**:

- محلی‌سازی وضعیت تا حد ممکن.
- استفاده از برش‌های خاص دامنه یا ارائه‌دهندگان زمینه.
- اجتناب از انتقال عمیق وضعیت جهانی.

<br />

### 16. چگونه ارزیابی می‌کنید که آیا یک ابزار یا کتابخانه جدید فرانت‌اند (مثل Vite، TanStack Query) ارزش پذیرش در یک پایگاه کد موجود را دارد؟

**معیارها**:

- بلوغ و اکوسیستم (مستندات، مسائل)
- مزایای تجربه توسعه در مقابل منحنی یادگیری
- سازگاری با پشته موجود
- مسیر انتشار: انتخابی یا مهاجرت کامل؟

**مثال**: برای پذیرش Vite:

- ساخت‌های محلی را معیارسنجی کردم (Vite 10 برابر سریع‌تر)
- سازگاری افزونه‌ها را تست کردم
- به‌صورت ویژگی‌به‌ویژگی منتشر شد تا ریسک کاهش یابد

<br />

### 17. نظر شما درباره تکامل بسته‌سازهای جاوااسکریپت از Webpack به Vite و ESBuild چیست؟

- **Webpack**: بسیار قابل تنظیم اما کندتر.
- **Vite**: از ماژول‌های ES و پشتیبانی بومی مرورگر بهره می‌برد، HMR سریع.
- **ESBuild**: فوق‌العاده سریع (مبتنی بر Go)، انعطاف‌پذیری کمتر.

**نتیجه‌گیری**: Vite برای توسعه مدرن با بازخورد سریع ایده‌آل است. Webpack همچنان در برنامه‌های قدیمی و پیچیده غالب است.

<br />

### 18. چگونه تنش بین پذیرش فناوری‌های پیشرفته فرانت‌اند و تضمین پایداری در تولید را مدیریت می‌کنید؟

**رویکرد**:

- **رادار فناوری**: دسته‌بندی ابزارها (پذیرش، آزمایش، نگه‌داری، ارزیابی).
- **انتشارهای کناری** یا سوئیچ‌های انتخابی برای انتشار تدریجی.
- **مستندات و آموزش** برای کاهش هزینه‌های ورود.
- تعادل بین بهره‌وری کوتاه‌مدت و قابلیت نگهداری بلندمدت.

<br />

### 19. مهم‌ترین محدودیت TypeScript در پروژه‌های فرانت‌اند بزرگ‌مقیاس چیست و چگونه آن را دور می‌زنید؟

**مشکل**: پیچیدگی در **جنریک‌های پیشرفته** و استنباط در ماژول‌ها.

**راه‌حل‌ها**:

- ترجیح عبارات تایپ ساده‌تر به جای پیچیده.
- استفاده از تایپ‌های ابزار و JSDoc برای قراردادهای پیچیده.
- مدولار کردن تایپ‌ها برای بهبود قابلیت نگهداری.

<br />

### 20. درباره نقش ابزارهای مبتنی بر هوش مصنوعی (مثل تولید کد، بهینه‌سازی خودکار) در آینده توسعه فرانت‌اند چگونه فکر می‌کنید؟

هوش مصنوعی برای موارد زیر عالی است:

- **تولید کد نمونه** (فرم‌ها، پیکربندی)
- **تحلیل دسترسی‌پذیری**
- **تولید تست**
- **بررسی کد و تشخیص الگو**

اما هنوز در موارد زیر ضعیف است:

- **تصمیم‌گیری‌های معماری**
- **تجربه کاربری خاص دامنه**

هوش مصنوعی نقش‌های ارشد فرانت‌اند را تقویت می‌کند، نه جایگزین. طراحی استراتژیک، ارتباطات و تفکر سیستمی همچنان انسانی باقی می‌مانند.

<br />

### 21. چگونه اطمینان می‌دهید که دسترسی‌پذیری در یک چرخه توسعه سریع به‌عنوان یک فکر بعدی در نظر گرفته نشود؟

**رویکرد:**

- **ادغام در فرآیند**: دسترسی‌پذیری (a11y) مثل پاسخ‌گویی یا تست غیراختیاری است.
- **استفاده از ابزارهای لینتینگ**: ادغام افزونه‌های ESLint مثل `jsx-a11y`.
- **کامپوننت‌های قابل دسترسی**: ساخت یا استفاده از سیستم طراحی (مثل Radix، Headless UI) با دسترسی‌پذیری داخلی.
- **تست دستی**: استفاده از ابزارهایی مثل **axe DevTools**، **VoiceOver** و **ناوبری کیبورد** در بررسی‌های PR.

```jsx
<button aria-label="Close modal">×</button>
```

<br />

### 22. سخت‌ترین چالش دسترسی‌پذیری که در یک برنامه React با آن مواجه شدید چیست و چگونه آن را برطرف کردید؟

**چالش**: ایجاد یک **منوی کشویی سفارشی** قابل دسترسی با کیبورد و دوستدار صفحه‌خوان.

**راه‌حل**:

- استفاده از `aria-expanded`، `aria-controls`، `role="menu"` و `role="menuitem"`.
- مدیریت رویدادهای کیبورد (`Enter`، `Esc`، `ArrowDown`، `ArrowUp`).
- استفاده از `useEffect` برای مدیریت فوکوس.
- تست با صفحه‌خوان‌ها در پلتفرم‌های مختلف (NVDA، VoiceOver).

<br />

### 23. چگونه یک سیستم فرانت‌اند طراحی می‌کنید که در مرورگرهای با سطوح مختلف پشتیبانی از ویژگی‌ها به‌زیبایی تنزل کند؟

**رویکرد**:

- **بهبود پیش‌رونده**: شروع با HTML معنایی، افزودن بهبودهای JS در بالا.
- **تشخیص ویژگی**: استفاده از `@supports` در CSS یا `window.CSS.supports()` در JS.

```jsx
if ("IntersectionObserver" in window) {
  // Use modern lazy-loading
} else {
  // Fallback: eager load or scroll events
}
```

- **پلی‌فیل‌ها**: استفاده گزینشی از سرویس‌های پلی‌فیل مدرن (مثل `core-js`، `polyfill.io`).

<br />

### 24. چگونه موفقیت یک برنامه فرانت‌اند را فراتر از معیارهای فنی مثل زمان بارگذاری یا حجم بسته اندازه‌گیری می‌کنید؟

**معیارهای کلیدی**:

- **تعامل کاربر**: نرخ بازگشت، مدت‌زمان جلسه، کلیک‌ها.
- **نرخ تبدیل**: اندازه‌گیری در مراحل خاص تجربه کاربری (مثل پرداخت).
- **موفقیت وظیفه**: درصد کاربرانی که جریان‌های کاری حیاتی را تکمیل می‌کنند.
- **رعایت دسترسی‌پذیری**: امتیاز ممیزی WCAG.
- **نرخ خطا**: خطاهای اجرایی JS، مشکلات API 4xx/5xx.

استفاده از ابزارهایی مثل **Amplitude**، **PostHog**، **Sentry** و **Google Lighthouse**.

<br />

### 25. رویکرد شما برای ساخت یک فرانت‌اند که در وب «بومی» به نظر برسد چیست و با چه تعارض‌هایی مواجه می‌شوید؟

**رویکرد**:

- اولویت‌بندی **بازخورد فوری** (انتقالات، تعاملات).
- استفاده از قراردادهای پلتفرم: رفتار اسکرول، ورودی‌ها، ژست‌ها.
- پذیرش **ویژگی‌های بومی مرورگر** مثل `datalist`، `input[type="date"]`، `prefers-reduced-motion`.

**تعارض‌ها**:

- برخی کامپوننت‌های بومی‌مانند (مثل انیمیشن‌ها) نیاز به پیچیدگی دارند.
- **تجربه کاربری چندپلتفرمی** می‌تواند متفاوت باشد—اندروید در مقابل iOS در مقابل دسکتاپ.

<br />

### 26. چگونه یک سیستم احراز هویت فرانت‌اند طراحی می‌کنید که هم ایمن باشد و هم کاربرپسند؟

**ایمن**:

- استفاده از **کوکی‌های HttpOnly، SameSite** برای جلوگیری از XSS/CSRF.
- احراز هویت از طریق **جریان‌های OAuth2/OIDC** (مثل Auth0).
- اعتبارسنجی توکن‌ها سمت سرور (بدون اعتماد به کلاینت).

**کاربرپسند**:

- ارائه بازخورد واضح در مورد شکست‌های احراز هویت.
- استفاده از **احراز هویت بدون رمز عبور** یا بیومتریک در صورت امکان.
- مدیریت **انقضای جلسه** به‌صورت زیبا.

<br />

### 27. ظریف‌ترین آسیب‌پذیری امنیتی که در یک برنامه فرانت‌اند با آن مواجه شدید چیست و چگونه آن را کشف و برطرف کردید؟

**مشکل**: یک بردار XSS ذخیره‌شده در فیلد بیوگرافی پروفایل کاربر که از طریق `dangerouslySetInnerHTML` نمایش داده می‌شد.

**رفع**:

- پاکسازی HTML با DOMPurify قبل از رندر.
- ممیزی تمام مناطق محتوای پویا با تحلیل کد استاتیک.
- جایگزینی `dangerouslySetInnerHTML` با رندرکننده مارک‌داون ایمن‌تر.

<br />

### 28. چگونه اطمینان می‌دهید که یک برنامه React در صورت خرابی یا تغییر غیرمنتظره وابستگی‌های شخص ثالث قابل اعتماد باقی می‌ماند؟

**استراتژی‌های مقاوم‌سازی**:

- **کامپوننت‌های رپ‌شده** با فال‌بک‌ها (مثلاً اگر یک ویجت نقشه بارگذاری نشود).
- تثبیت نسخه‌های وابستگی (`package-lock`، `pnpm-lock.yaml`).
- استفاده از **مرزهای خطا**:

```jsx
<ErrorBoundary fallback={<FallbackUI />}>
  <ThirdPartyComponent />
</ErrorBoundary>
```

- نظارت بر APIهای خارجی با بررسی‌های سلامت در زمان اجرا.

<br />

### 29. استراتژی شما برای مدیریت خطاهای فرانت‌اند در تولید در مقیاس چیست؟

- استفاده از **ابزارهای نظارت بر خطا** (مثل Sentry، Bugsnag).
- پیاده‌سازی **مرزهای خطا** برای گرفتن و ایزوله کردن خطاهای رندر.
- برچسب‌گذاری خطاها با زمینه کاربر/جلسه (ناشناس).
- تجمیع، هشدار و اولویت‌بندی بر اساس فراوانی و تأثیر.

<br />

### 30. درباره تعامل بین امنیت فرانت‌اند و بک‌اند در یک برنامه فول‌استک چگونه فکر می‌کنید؟

- **فرانت‌اند** محدودیت‌های سطح تجربه کاربری را اعمال می‌کند (مثل غیرفعال کردن دکمه‌ها، اعتبارسنجی اولیه).
- **بک‌اند** دروازه‌بان نهایی است: تمام ورودی‌ها باید اعتبارسنجی و مجاز شوند.
- هرگز اسرار یا منطق احراز هویت را در کلاینت افشا نکنید.
- استفاده از **توکن‌های CSRF**، **محدودیت نرخ** و **اعتبارسنجی ورودی** در هر دو طرف.

<br />

### 31. مهم‌ترین درسی که درباره رهبری تیم‌های فرانت‌اند آموخته‌اید و کاش زودتر در حرفه‌تان می‌دانستید چیست؟

**درس**: **شفافیت بر هوشمندی برتری دارد**.

- کد خوانا و ساده بهتر از هک‌های هوشمند مقیاس‌پذیر است.
- تشویق به مستندسازی و لاگ‌های تصمیم‌گیری.
- توانمندسازی توسعه‌دهندگان junior با مربیگری، نه دروازه‌بانی.

<br />

### 32. چگونه فرهنگ آزمایش را در یک تیم فرانت‌اند پرورش می‌دهید در حالی که استانداردهای بالای کیفیت را حفظ می‌کنید؟

- استفاده از **پرچم‌های ویژگی** برای تست ایمن در تولید.
- تشویق به شاخه‌های آزمایشی برای نمونه‌های اولیه.
- جشن گرفتن یادگیری از آزمایش‌های ناموفق.
- حفظ استانداردهای سخت‌گیرانه PR: حتی کد آزمایشی باید تست و بررسی شود.

<br />

### 33. فلسفه شما درباره بدهی فنی در توسعه فرانت‌اند چیست؟

**فلسفه**:

- همه بدهی‌ها بد نیستند—**بدهی عمدی** می‌تواند سرعت را بخرد.
- آن را مثل اشکالات در بک‌لاگ ردیابی کنید.
- برنامه‌ریزی **اسپرینت‌های مهندسی** برای پاکسازی.
- استفاده از **بررسی‌های کد** برای جلوگیری از تجمع بدهی غیرعمدی.

<br />

### 34. چگونه تنش بین ارائه ارزش تجاری سریع و ساخت یک سیستم فرانت‌اند با کیفیت فنی را مدیریت می‌کنید؟

- ترجیح **تحویل تدریجی**: شروع کوچک اما طراحی برای مقیاس.
- هم‌راستایی با محصول: نشان دادن اینکه معماری خوب ویژگی‌های سریع‌تر را در آینده ممکن می‌کند.
- حمایت از **توسعه دو مسیره**: کشف تجربه کاربری + مهندسی قبل از پیاده‌سازی.

<br />

### 35. بزرگ‌ترین مشکل حل‌نشده در توسعه فرانت‌اند امروز چیست و چگونه به حل آن رویکرد می‌کنید؟

**مشکل**: **مدیریت وضعیت پایدار در مقیاس**—تعادل بین وضعیت محلی، جهانی و سرور.

**چرا دشوار است**: نیازهای رابط کاربری پیچیده اغلب با عملکرد و سادگی در تضاد هستند.

**رویکرد**:

- استفاده از ابزارهایی مثل **Zustand**، **TanStack Query** یا **Recoil** که کد نمونه کم و وضعیت محدود ارائه می‌دهند.
- تدوین دستورالعمل‌های تیمی مشترک برای مکان/زمان ذخیره وضعیت (کامپوننت در مقابل زمینه در مقابل کش).
- بلندمدت: سرمایه‌گذاری در **ادغام‌های واکنشی بک‌اند** (مثل اشتراک‌های GraphQL، TRPC) برای کاهش تکرار منطق وضعیت.